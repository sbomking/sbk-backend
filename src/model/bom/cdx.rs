use serde::{Deserialize, Serialize};

use crate::model::bom::JsfSignature;

/**
 * Code generated by schemafy
 */

#[doc = " Title and location where advisory information can be obtained. An advisory is a notification of "]
#[doc = " a threat to a component, service, or system."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "advisory")]
#[serde(deny_unknown_fields)]
pub struct Advisory {
    #[doc = " An optional name of the advisory."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    #[doc = " Location where the advisory can be obtained."]
    pub url: String,
}
#[doc = " The vulnerability status of a given version or range of versions of a product. The statuses "]
#[doc = " 'affected' and 'unaffected' indicate that the version is affected or unaffected by the "]
#[doc = " vulnerability. The status 'unknown' indicates that it is unknown or unspecified whether the "]
#[doc = " given version is affected. There can be many reasons for an 'unknown' status, including that an "]
#[doc = " investigation has not been undertaken or that a vendor has not disclosed the status."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "affectedStatus")]
pub enum AffectedStatus {
    #[serde(rename = "affected")]
    Affected,
    #[serde(rename = "unaffected")]
    Unaffected,
    #[serde(rename = "unknown")]
    Unknown,
}
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "aggregateType")]
pub enum AggregateType {
    #[serde(rename = "complete")]
    Complete,
    #[serde(rename = "incomplete")]
    Incomplete,
    #[serde(rename = "incomplete_first_party_only")]
    IncompleteFirstPartyOnly,
    #[serde(rename = "incomplete_first_party_proprietary_only")]
    IncompleteFirstPartyProprietaryOnly,
    #[serde(rename = "incomplete_first_party_opensource_only")]
    IncompleteFirstPartyOpensourceOnly,
    #[serde(rename = "incomplete_third_party_only")]
    IncompleteThirdPartyOnly,
    #[serde(rename = "incomplete_third_party_proprietary_only")]
    IncompleteThirdPartyProprietaryOnly,
    #[serde(rename = "incomplete_third_party_opensource_only")]
    IncompleteThirdPartyOpensourceOnly,
    #[serde(rename = "unknown")]
    Unknown,
    #[serde(rename = "not_specified")]
    NotSpecified,
}
pub type AnnotationsAnnotatorVariant0 = serde_json::Value;
pub type AnnotationsAnnotatorVariant1 = serde_json::Value;
pub type AnnotationsAnnotatorVariant2 = serde_json::Value;
pub type AnnotationsAnnotatorVariant3 = serde_json::Value;
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnnotationsAnnotator {
    Variant0(AnnotationsAnnotatorVariant0),
    Variant1(AnnotationsAnnotatorVariant1),
    Variant2(AnnotationsAnnotatorVariant2),
    Variant3(AnnotationsAnnotatorVariant3),
}
#[doc = " A comment, note, explanation, or similar textual content which provides additional context to "]
#[doc = " the object(s) being annotated."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "annotations")]
#[serde(deny_unknown_fields)]
pub struct Annotations {
    #[doc = " The organization, person, component, or service which created the textual content of the "]
    #[doc = " annotation."]
    pub annotator: AnnotationsAnnotator,
    #[doc = " An optional identifier which can be used to reference the annotation elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with "]
    #[doc = " BOM-Links."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " Enveloped signature in [JSON Signature Format "]
    #[doc = " (JSF)](https://cyberphone.github.io/doc/security/jsf.html)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<JsfSignature>,
    #[doc = " The object in the BOM identified by its bom-ref. This is often a component or service, but "]
    #[doc = " may be any object type supporting bom-refs."]
    pub subjects: Vec<serde_json::Value>,
    #[doc = " The textual content of the annotation."]
    pub text: String,
    #[doc = " The date and time (timestamp) when the annotation was created."]
    pub timestamp: String,
}
#[doc = " Specifies the metadata and content for an attachment."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "attachment")]
#[serde(deny_unknown_fields)]
pub struct Attachment {
    #[doc = " The attachment data. Proactive controls such as input validation and sanitization should be "]
    #[doc = " employed to prevent misuse of attachment text."]
    pub content: String,
    #[doc = " Specifies the format and nature of the data being attached, helping systems correctly "]
    #[doc = " interpret and process the content. Common content type examples include `application/json` "]
    #[doc = " for JSON data and `text/plain` for plan text documents."]
    #[doc = "  [RFC 2045 section 5.1](https://www.ietf.org/rfc/rfc2045.html#section-5.1) outlines the "]
    #[doc = " structure and use of content types. For a comprehensive list of registered content types, "]
    #[doc = " refer to the [IANA media types "]
    #[doc = " registry](https://www.iana.org/assignments/media-types/media-types.xhtml)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "contentType")]
    pub content_type: Option<String>,
    #[doc = " Specifies the optional encoding the text is represented in."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encoding: Option<String>,
}
pub type BomLink = serde_json::Value;
#[doc = " Descriptor for another BOM document. See https://cyclonedx.org/capabilities/bomlink/"]
pub type BomLinkDocumentType = String;
#[doc = " Descriptor for an element in a BOM document. See https://cyclonedx.org/capabilities/bomlink/"]
pub type BomLinkElementType = String;
#[doc = " Object representing a cipher suite"]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "cipherSuite")]
#[serde(deny_unknown_fields)]
pub struct CipherSuite {
    #[doc = " A list of algorithms related to the cipher suite."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub algorithms: Option<Vec<RefType>>,
    #[doc = " A list of common identifiers for the cipher suite."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub identifiers: Option<Vec<String>>,
    #[doc = " A common name for the cipher suite."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}
#[doc = " A measure of carbon dioxide (CO2)."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "co2Measure")]
#[serde(deny_unknown_fields)]
pub struct Co2Measure {
    #[doc = " Unit of carbon dioxide (CO2)."]
    pub unit: String,
    #[doc = " Quantity of carbon dioxide (CO2)."]
    pub value: f64,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "command")]
#[serde(deny_unknown_fields)]
pub struct Command {
    #[doc = " A text representation of the executed command."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub executed: Option<String>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
}
#[doc = " Specifies an individual commit"]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "commit")]
#[serde(deny_unknown_fields)]
pub struct Commit {
    #[doc = " The author who created the changes in the commit"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub author: Option<IdentifiableAction>,
    #[doc = " The person who committed or pushed the commit"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub committer: Option<IdentifiableAction>,
    #[doc = " The text description of the contents of the commit"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[doc = " A unique identifier of the commit. This may be version control specific. For example, "]
    #[doc = " Subversion uses revision numbers whereas git uses commit hashes."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
    #[doc = " The URL to the commit. This URL will typically point to a commit in a version control "]
    #[doc = " system."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ComponentPedigree {
    #[doc = " Describes zero or more components in which a component is derived from. This is commonly "]
    #[doc = " used to describe forks from existing projects where the forked version contains a ancestor "]
    #[doc = " node containing the original component it was forked from. For example, Component A is the "]
    #[doc = " original component. Component B is the component being used and documented in the BOM. "]
    #[doc = " However, Component B contains a pedigree node with a single ancestor documenting Component "]
    #[doc = " A - the original component from which Component B is derived from."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ancestors: Option<Vec<Component>>,
    #[doc = " A list of zero or more commits which provide a trail describing how the component deviates "]
    #[doc = " from an ancestor, descendant, or variant."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub commits: Option<Vec<Commit>>,
    #[doc = " Descendants are the exact opposite of ancestors. This provides a way to document all forks "]
    #[doc = " (and their forks) of an original or root component."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub descendants: Option<Vec<Component>>,
    #[doc = " Notes, observations, and other non-structured commentary describing the components "]
    #[doc = " pedigree."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notes: Option<String>,
    #[doc = " >A list of zero or more patches describing how the component deviates from an ancestor, "]
    #[doc = " descendant, or variant. Patches may be complementary to commits or may be used in place of "]
    #[doc = " commits."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub patches: Option<Vec<Patch>>,
    #[doc = " Variants describe relations where the relationship between the components is not known. For "]
    #[doc = " example, if Component A contains nearly identical code to Component B. They are both "]
    #[doc = " related, but it is unclear if one is derived from the other, or if they share a common "]
    #[doc = " ancestor."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub variants: Option<Vec<Component>>,
}
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "component")]
#[serde(deny_unknown_fields)]
pub struct Component {
    #[doc = " [Deprecated] This will be removed in a future version. Use `@.authors` or `@.manufacturer` "]
    #[doc = " instead."]
    #[doc = " The person(s) or organization(s) that authored the component"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub author: Option<String>,
    #[doc = " The person(s) who created the component."]
    #[doc = " Authors are common in components created through manual processes. Components created "]
    #[doc = " through automated means may have `@.manufacturer` instead."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authors: Option<Vec<OrganizationalContact>>,
    #[doc = " An optional identifier which can be used to reference the component elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with "]
    #[doc = " BOM-Links."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " A list of software and hardware components included in the parent component. This is not a "]
    #[doc = " dependency tree. It provides a way to specify a hierarchical representation of component "]
    #[doc = " assemblies, similar to system &#8594; subsystem &#8594; parts assembly in physical supply "]
    #[doc = " chains."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub components: Option<Vec<Component>>,
    #[doc = " A copyright notice informing users of the underlying claims to copyright ownership in a "]
    #[doc = " published work."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub copyright: Option<String>,
    #[doc = " Asserts the identity of the component using CPE. The CPE must conform to the CPE 2.2 or 2.3 "]
    #[doc = " specification. See [https://nvd.nist.gov/products/cpe](https://nvd.nist.gov/products/cpe). "]
    #[doc = " Refer to `@.evidence.identity` to optionally provide evidence that substantiates the "]
    #[doc = " assertion of the component's identity."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cpe: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "cryptoProperties")]
    pub crypto_properties: Option<CryptoProperties>,
    #[doc = " This object SHOULD be specified for any component of type `data` and must not be specified "]
    #[doc = " for other component types."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<Vec<ComponentData>>,
    #[doc = " Specifies a description for the component"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = " Provides the ability to document evidence collected through various forms of extraction or "]
    #[doc = " analysis."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub evidence: Option<ComponentEvidence>,
    #[doc = " External references provide a way to document systems, sites, and information that may be "]
    #[doc = " relevant but are not included with the BOM. They may also establish specific relationships "]
    #[doc = " within or external to the BOM."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "externalReferences")]
    pub external_references: Option<Vec<ExternalReference>>,
    #[doc = " The grouping name or identifier. This will often be a shortened, single name of the company "]
    #[doc = " or project that produced the component, or the source package or domain name. Whitespace "]
    #[doc = " and special characters should be avoided. Examples include: apache, org.apache.commons, and "]
    #[doc = " apache.org."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    #[doc = " The hashes of the component."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hashes: Option<Vec<Hash>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub licenses: Option<LicenseChoice>,
    #[doc = " The organization that created the component."]
    #[doc = " Manufacturer is common in components created through automated processes. Components "]
    #[doc = " created through manual means may have `@.authors` instead."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub manufacturer: Option<OrganizationalEntity>,
    #[doc = " The optional mime-type of the component. When used on file components, the mime-type can "]
    #[doc = " provide additional context about the kind of file being represented, such as an image, "]
    #[doc = " font, or executable. Some library or framework components may also have an associated "]
    #[doc = " mime-type."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "mime-type")]
    pub mime_type: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "modelCard")]
    pub model_card: Option<ModelCard>,
    #[doc = " [Deprecated] This will be removed in a future version. Use the pedigree element instead to "]
    #[doc = " supply information on exactly how the component was modified. A boolean value indicating if "]
    #[doc = " the component has been modified from the original. A value of true indicates the component "]
    #[doc = " is a derivative of the original. A value of false indicates the component has not been "]
    #[doc = " modified from the original."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub modified: Option<bool>,
    #[doc = " The name of the component. This will often be a shortened, single name of the component. "]
    #[doc = " Examples: commons-lang3 and jquery"]
    pub name: String,
    #[doc = " Asserts the identity of the component using the OmniBOR Artifact ID. The OmniBOR, if "]
    #[doc = " specified, must be valid and conform to the specification defined at: "]
    #[doc = " [https://www.iana.org/assignments/uri-schemes/prov/gitoid](https://www.iana.org/assignments/uri-schemes/prov/gitoid). "]
    #[doc = " Refer to `@.evidence.identity` to optionally provide evidence that substantiates the "]
    #[doc = " assertion of the component's identity."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "omniborId")]
    pub omnibor_id: Option<Vec<String>>,
    #[doc = " Component pedigree is a way to document complex supply chain scenarios where components are "]
    #[doc = " created, distributed, modified, redistributed, combined with other components, etc. "]
    #[doc = " Pedigree supports viewing this complex chain from the beginning, the end, or anywhere in "]
    #[doc = " the middle. It also provides a way to document variants where the exact relation may not be "]
    #[doc = " known."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pedigree: Option<ComponentPedigree>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
    #[doc = " The person(s) or organization(s) that published the component"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub publisher: Option<String>,
    #[doc = " Asserts the identity of the component using package-url (purl). The purl, if specified, "]
    #[doc = " must be valid and conform to the specification defined at: "]
    #[doc = " [https://github.com/package-url/purl-spec](https://github.com/package-url/purl-spec). Refer "]
    #[doc = " to `@.evidence.identity` to optionally provide evidence that substantiates the assertion of "]
    #[doc = " the component's identity."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub purl: Option<String>,
    #[doc = " Specifies optional release notes."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "releaseNotes")]
    pub release_notes: Option<ReleaseNotes>,
    #[doc = " Specifies the scope of the component. If scope is not specified, 'required' scope SHOULD be "]
    #[doc = " assumed by the consumer of the BOM."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scope: Option<String>,
    #[doc = " Enveloped signature in [JSON Signature Format "]
    #[doc = " (JSF)](https://cyberphone.github.io/doc/security/jsf.html)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<JsfSignature>,
    #[doc = "  The organization that supplied the component. The supplier may often be the manufacturer, "]
    #[doc = " but may also be a distributor or repackager."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supplier: Option<OrganizationalEntity>,
    #[doc = " Asserts the identity of the component using the Software Heritage persistent identifier "]
    #[doc = " (SWHID). The SWHID, if specified, must be valid and conform to the specification defined "]
    #[doc = " at: "]
    #[doc = " [https://docs.softwareheritage.org/devel/swh-model/persistent-identifiers.html](https://docs.softwareheritage.org/devel/swh-model/persistent-identifiers.html). "]
    #[doc = " Refer to `@.evidence.identity` to optionally provide evidence that substantiates the "]
    #[doc = " assertion of the component's identity."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub swhid: Option<Vec<String>>,
    #[doc = " Asserts the identity of the component using [ISO-IEC 19770-2 Software Identification (SWID) "]
    #[doc = " Tags](https://www.iso.org/standard/65666.html). Refer to `@.evidence.identity` to "]
    #[doc = " optionally provide evidence that substantiates the assertion of the component's identity."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub swid: Option<Swid>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Tags>,
    #[doc = " Specifies the type of component. For software components, classify as application if no "]
    #[doc = " more specific appropriate classification is available or cannot be determined for the "]
    #[doc = " component."]
    #[serde(rename = "type")]
    pub type_: String,
    #[doc = " The component version. The version should ideally comply with semantic versioning but is "]
    #[doc = " not enforced."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<Version>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ComponentDataContents {
    #[doc = " An optional way to include textual or encoded data."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attachment: Option<Attachment>,
    #[doc = " Provides the ability to document name-value parameters used for configuration."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
    #[doc = " The URL to where the data can be retrieved."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "componentData")]
#[serde(deny_unknown_fields)]
pub struct ComponentData {
    #[doc = " An optional identifier which can be used to reference the dataset elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with "]
    #[doc = " BOM-Links."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub classification: Option<DataClassification>,
    #[doc = " The contents or references to the contents of the data being described."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<ComponentDataContents>,
    #[doc = " A description of the dataset. Can describe size of dataset, whether it's used for source "]
    #[doc = " code, training, testing, or validation, etc."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub governance: Option<DataGovernance>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub graphics: Option<GraphicsCollection>,
    #[doc = " The name of the dataset."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = " A description of any sensitive data in a dataset."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "sensitiveData")]
    pub sensitive_data: Option<Vec<String>>,
    #[doc = " The general theme or subject matter of the data being specified."]
    #[serde(rename = "type")]
    pub type_: String,
}
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ComponentEvidenceCallstackItemFrames {
    #[doc = " The column the code that is called resides."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub column: Option<i64>,
    #[doc = " The full path and filename of the module."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "fullFilename")]
    pub full_filename: Option<String>,
    #[doc = " A block of code designed to perform a particular task."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub function: Option<String>,
    #[doc = " The line number the code that is called resides on."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub line: Option<i64>,
    #[doc = " A module or class that encloses functions/methods and other code."]
    pub module: String,
    #[doc = " A package organizes modules into namespaces, providing a unique namespace for each type it "]
    #[doc = " contains."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub package: Option<String>,
    #[doc = " Optional arguments that are passed to the module or function."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<Vec<String>>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ComponentEvidenceCallstack {
    #[doc = " Within a call stack, a frame is a discrete unit that encapsulates an execution context, "]
    #[doc = " including local variables, parameters, and the return address. As function calls are made, "]
    #[doc = " frames are pushed onto the stack, forming an array-like structure that orchestrates the "]
    #[doc = " flow of program execution and manages the sequence of function invocations."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frames: Option<Vec<ComponentEvidenceCallstackItemFrames>>,
}
pub type ComponentEvidenceIdentityVariant0 = Vec<ComponentIdentityEvidence>;
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ComponentEvidenceIdentity {
    Variant0(ComponentEvidenceIdentityVariant0),
    Variant1(ComponentIdentityEvidence),
}
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ComponentEvidenceItemOccurrences {
    #[doc = " Any additional context of the detected component (e.g. a code snippet)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "additionalContext")]
    pub additional_context: Option<String>,
    #[doc = " An optional identifier which can be used to reference the occurrence elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with "]
    #[doc = " BOM-Links."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " The line number where the component was found."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub line: Option<i64>,
    #[doc = " The location or path to where the component was found."]
    pub location: String,
    #[doc = " The offset where the component was found."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub offset: Option<i64>,
    #[doc = " The symbol name that was found associated with the component."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub symbol: Option<String>,
}
#[doc = " Provides the ability to document evidence collected through various forms of extraction or "]
#[doc = " analysis."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "componentEvidence")]
#[serde(deny_unknown_fields)]
pub struct ComponentEvidence {
    #[doc = " Evidence of the components use through the callstack."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub callstack: Option<ComponentEvidenceCallstack>,
    #[doc = " Copyright evidence captures intellectual property assertions, providing evidence of "]
    #[doc = " possible ownership and legal protection."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub copyright: Option<Vec<Copyright>>,
    #[doc = " Evidence that substantiates the identity of a component. The identity may be an object or "]
    #[doc = " an array of identity objects. Support for specifying identity as a single object was "]
    #[doc = " introduced in CycloneDX v1.5. Arrays were introduced in v1.6. It is recommended that all "]
    #[doc = " implementations use arrays, even if only one identity object is specified."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub identity: Option<ComponentEvidenceIdentity>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub licenses: Option<LicenseChoice>,
    #[doc = " Evidence of individual instances of a component spread across multiple locations."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub occurrences: Option<Vec<ComponentEvidenceItemOccurrences>>,
}
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ComponentIdentityEvidenceItemMethods {
    #[doc = " The confidence of the evidence from 0 - 1, where 1 is 100% confidence. Confidence is "]
    #[doc = " specific to the technique used. Each technique of analysis can have independent confidence."]
    pub confidence: f64,
    #[doc = " The technique used in this method of analysis."]
    pub technique: String,
    #[doc = " The value or contents of the evidence."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}
#[doc = " Evidence that substantiates the identity of a component."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "componentIdentityEvidence")]
#[serde(deny_unknown_fields)]
pub struct ComponentIdentityEvidence {
    #[doc = " The value of the field (cpe, purl, etc) that has been concluded based on the aggregate of "]
    #[doc = " all methods (if available)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "concludedValue")]
    pub concluded_value: Option<String>,
    #[doc = " The overall confidence of the evidence from 0 - 1, where 1 is 100% confidence."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub confidence: Option<f64>,
    #[doc = " The identity field of the component which the evidence describes."]
    pub field: String,
    #[doc = " The methods used to extract and/or analyze the evidence."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub methods: Option<Vec<ComponentIdentityEvidenceItemMethods>>,
    #[doc = " The object in the BOM identified by its bom-ref. This is often a component or service but "]
    #[doc = " may be any object type supporting bom-refs. Tools used for analysis should already be "]
    #[doc = " defined in the BOM, either in the metadata/tools, components, or formulation."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tools: Option<Vec<serde_json::Value>>,
}
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "compositions")]
#[serde(deny_unknown_fields)]
pub struct Compositions {
    #[doc = " Specifies an aggregate type that describe how complete a relationship is."]
    pub aggregate: AggregateType,
    #[doc = " The bom-ref identifiers of the components or services being described. Assemblies refer to "]
    #[doc = " nested relationships whereby a constituent part may include other constituent parts. "]
    #[doc = " References do not cascade to child parts. References are explicit for the specified "]
    #[doc = " constituent part only."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assemblies: Option<Vec<serde_json::Value>>,
    #[doc = " An optional identifier which can be used to reference the composition elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with "]
    #[doc = " BOM-Links."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " The bom-ref identifiers of the components or services being described. Dependencies refer "]
    #[doc = " to a relationship whereby an independent constituent part requires another independent "]
    #[doc = " constituent part. References do not cascade to transitive dependencies. References are "]
    #[doc = " explicit for the specified dependency only."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dependencies: Option<Vec<String>>,
    #[doc = " Enveloped signature in [JSON Signature Format "]
    #[doc = " (JSF)](https://cyberphone.github.io/doc/security/jsf.html)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<JsfSignature>,
    #[doc = " The bom-ref identifiers of the vulnerabilities being described."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vulnerabilities: Option<Vec<String>>,
}
#[doc = " A condition that was used to determine a trigger should be activated."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "condition")]
#[serde(deny_unknown_fields)]
pub struct Condition {
    #[doc = " Describes the set of conditions which cause the trigger to activate."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = " The logical expression that was evaluated that determined the trigger should be fired."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
}
#[doc = " A copyright notice informing users of the underlying claims to copyright ownership in a "]
#[doc = " published work."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "copyright")]
#[serde(deny_unknown_fields)]
pub struct Copyright {
    #[doc = " The textual content of the copyright."]
    pub text: String,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CryptoPropertiesAlgorithmProperties {
    #[doc = " The certification that the implementation of the cryptographic algorithm has received, if "]
    #[doc = " any. Certifications include revisions and levels of FIPS 140 or Common Criteria of "]
    #[doc = " different Extended Assurance Levels (CC-EAL)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "certificationLevel")]
    pub certification_level: Option<Vec<String>>,
    #[doc = " The classical security level that a cryptographic algorithm provides (in bits)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "classicalSecurityLevel")]
    pub classical_security_level: Option<i64>,
    #[doc = " The cryptographic functions implemented by the cryptographic algorithm."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "cryptoFunctions")]
    pub crypto_functions: Option<Vec<String>>,
    #[doc = " The specific underlying Elliptic Curve (EC) definition employed which is an indicator of "]
    #[doc = " the level of security strength, performance and complexity. Absent an authoritative source "]
    #[doc = " of curve names, CycloneDX recommends using curve names as defined at "]
    #[doc = " [https://neuromancer.sk/std/](https://neuromancer.sk/std/), the source of which can be "]
    #[doc = " found at [https://github.com/J08nY/std-curves](https://github.com/J08nY/std-curves)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub curve: Option<String>,
    #[doc = " The target and execution environment in which the algorithm is implemented in."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "executionEnvironment")]
    pub execution_environment: Option<String>,
    #[doc = " The target platform for which the algorithm is implemented. The implementation can be "]
    #[doc = " 'generic', running on any platform or for a specific platform."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "implementationPlatform")]
    pub implementation_platform: Option<String>,
    #[doc = " The mode of operation in which the cryptographic algorithm (block cipher) is used."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    #[doc = " The NIST security strength category as defined in "]
    #[doc = " https://csrc.nist.gov/projects/post-quantum-cryptography/post-quantum-cryptography-standardization/evaluation-criteria/security-(evaluation-criteria). "]
    #[doc = " A value of 0 indicates that none of the categories are met."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "nistQuantumSecurityLevel")]
    pub nist_quantum_security_level: Option<i64>,
    #[doc = " The padding scheme that is used for the cryptographic algorithm."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub padding: Option<String>,
    #[doc = " An identifier for the parameter set of the cryptographic algorithm. Examples: in AES128, "]
    #[doc = " '128' identifies the key length in bits, in SHA256, '256' identifies the digest length, "]
    #[doc = " '128' in SHAKE128 identifies its maximum security level in bits, and 'SHA2-128s' identifies "]
    #[doc = " a parameter set used in SLH-DSA (FIPS205)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "parameterSetIdentifier")]
    pub parameter_set_identifier: Option<String>,
    #[doc = " Cryptographic building blocks used in higher-level cryptographic systems and protocols. "]
    #[doc = " Primitives represent different cryptographic routines: deterministic random bit generators "]
    #[doc = " (drbg, e.g. CTR_DRBG from NIST SP800-90A-r1), message authentication codes (mac, e.g. "]
    #[doc = " HMAC-SHA-256), blockciphers (e.g. AES), streamciphers (e.g. Salsa20), signatures (e.g. "]
    #[doc = " ECDSA), hash functions (e.g. SHA-256), public-key encryption schemes (pke, e.g. RSA), "]
    #[doc = " extended output functions (xof, e.g. SHAKE256), key derivation functions (e.g. pbkdf2), key "]
    #[doc = " agreement algorithms (e.g. ECDH), key encapsulation mechanisms (e.g. ML-KEM), authenticated "]
    #[doc = " encryption (ae, e.g. AES-GCM) and the combination of multiple algorithms (combiner, e.g. "]
    #[doc = " SP800-56Cr2)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primitive: Option<String>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CryptoPropertiesCertificateProperties {
    #[doc = " The file extension of the certificate"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "certificateExtension")]
    pub certificate_extension: Option<String>,
    #[doc = " The format of the certificate"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "certificateFormat")]
    pub certificate_format: Option<String>,
    #[doc = " The issuer name for the certificate"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "issuerName")]
    pub issuer_name: Option<String>,
    #[doc = " The date and time according to ISO-8601 standard from which the certificate is not valid "]
    #[doc = " anymore"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "notValidAfter")]
    pub not_valid_after: Option<String>,
    #[doc = " The date and time according to ISO-8601 standard from which the certificate is valid"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "notValidBefore")]
    pub not_valid_before: Option<String>,
    #[doc = " The bom-ref to signature algorithm used by the certificate"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "signatureAlgorithmRef")]
    pub signature_algorithm_ref: Option<RefType>,
    #[doc = " The subject name for the certificate"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "subjectName")]
    pub subject_name: Option<String>,
    #[doc = " The bom-ref to the public key of the subject"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "subjectPublicKeyRef")]
    pub subject_public_key_ref: Option<RefType>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CryptoPropertiesProtocolPropertiesIkev2TransformTypes {
    #[doc = " IKEv2 Authentication method"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auth: Option<CryptoRefArray>,
    #[doc = " Transform Type 1: encryption algorithms"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encr: Option<CryptoRefArray>,
    #[doc = " Specifies if an Extended Sequence Number (ESN) is used."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub esn: Option<bool>,
    #[doc = " Transform Type 3: integrity algorithms"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub integ: Option<CryptoRefArray>,
    #[doc = " Transform Type 4: Key Exchange Method (KE) per [RFC "]
    #[doc = " 9370](https://www.ietf.org/rfc/rfc9370.html), formerly called Diffie-Hellman Group (D-H)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ke: Option<CryptoRefArray>,
    #[doc = " Transform Type 2: pseudorandom functions"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prf: Option<CryptoRefArray>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CryptoPropertiesProtocolProperties {
    #[doc = " A list of cipher suites related to the protocol."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "cipherSuites")]
    pub cipher_suites: Option<Vec<CipherSuite>>,
    #[doc = " A list of protocol-related cryptographic assets"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "cryptoRefArray")]
    pub crypto_ref_array: Option<CryptoRefArray>,
    #[doc = " The IKEv2 transform types supported (types 1-4), defined in [RFC 7296 section "]
    #[doc = " 3.3.2](https://www.ietf.org/rfc/rfc7296.html#section-3.3.2), and additional properties."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "ikev2TransformTypes")]
    pub ikev_2_transform_types: Option<CryptoPropertiesProtocolPropertiesIkev2TransformTypes>,
    #[doc = " The concrete protocol type."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "type")]
    pub type_: Option<String>,
    #[doc = " The version of the protocol."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CryptoPropertiesRelatedCryptoMaterialProperties {
    #[doc = " The date and time (timestamp) when the related cryptographic material was activated."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "activationDate")]
    pub activation_date: Option<String>,
    #[doc = " The bom-ref to the algorithm used to generate the related cryptographic material."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "algorithmRef")]
    pub algorithm_ref: Option<RefType>,
    #[doc = " The date and time (timestamp) when the related cryptographic material was created."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "creationDate")]
    pub creation_date: Option<String>,
    #[doc = " The date and time (timestamp) when the related cryptographic material expires."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "expirationDate")]
    pub expiration_date: Option<String>,
    #[doc = " The format of the related cryptographic material (e.g. P8, PEM, DER)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<String>,
    #[doc = " The optional unique identifier for the related cryptographic material."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = " The mechanism by which the cryptographic asset is secured by."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "securedBy")]
    pub secured_by: Option<SecuredBy>,
    #[doc = " The size of the cryptographic asset (in bits)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<i64>,
    #[doc = " The key state as defined by NIST SP 800-57."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
    #[doc = " The type for the related cryptographic material"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "type")]
    pub type_: Option<String>,
    #[doc = " The date and time (timestamp) when the related cryptographic material was updated."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "updateDate")]
    pub update_date: Option<String>,
    #[doc = " The associated value of the cryptographic material."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}
#[doc = " Cryptographic assets have properties that uniquely define them and that make them actionable "]
#[doc = " for further reasoning. As an example, it makes a difference if one knows the algorithm family "]
#[doc = " (e.g. AES) or the specific variant or instantiation (e.g. AES-128-GCM). This is because the "]
#[doc = " security level and the algorithm primitive (authenticated encryption) are only defined by the "]
#[doc = " definition of the algorithm variant. The presence of a weak cryptographic algorithm like SHA1 "]
#[doc = " vs. HMAC-SHA1 also makes a difference."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "cryptoProperties")]
#[serde(deny_unknown_fields)]
pub struct CryptoProperties {
    #[doc = " Additional properties specific to a cryptographic algorithm."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "algorithmProperties")]
    pub algorithm_properties: Option<CryptoPropertiesAlgorithmProperties>,
    #[doc = " Cryptographic assets occur in several forms. Algorithms and protocols are most commonly "]
    #[doc = " implemented in specialized cryptographic libraries. They may, however, also be 'hardcoded' "]
    #[doc = " in software components. Certificates and related cryptographic material like keys, tokens, "]
    #[doc = " secrets or passwords are other cryptographic assets to be modelled."]
    #[serde(rename = "assetType")]
    pub asset_type: String,
    #[doc = " Properties for cryptographic assets of asset type 'certificate'"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "certificateProperties")]
    pub certificate_properties: Option<CryptoPropertiesCertificateProperties>,
    #[doc = " The object identifier (OID) of the cryptographic asset."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oid: Option<String>,
    #[doc = " Properties specific to cryptographic assets of type: `protocol`."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "protocolProperties")]
    pub protocol_properties: Option<CryptoPropertiesProtocolProperties>,
    #[doc = " Properties for cryptographic assets of asset type: `related-crypto-material`"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "relatedCryptoMaterialProperties")]
    pub related_crypto_material_properties: Option<CryptoPropertiesRelatedCryptoMaterialProperties>,
}
pub type CryptoRefArray = Vec<RefType>;
#[doc = " Integer representation of a Common Weaknesses Enumerations (CWE). For example 399 (of "]
#[doc = " https://cwe.mitre.org/data/definitions/399.html)"]
pub type Cwe = i64;
#[doc = " Data classification tags data according to its type, sensitivity, and value if altered, stolen, "]
#[doc = " or destroyed."]
pub type DataClassification = String;
#[doc = " Specifies the flow direction of the data. Direction is relative to the service."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "dataFlowDirection")]
pub enum DataFlowDirection {
    #[serde(rename = "inbound")]
    Inbound,
    #[serde(rename = "outbound")]
    Outbound,
    #[serde(rename = "bi-directional")]
    BiDirectional,
    #[serde(rename = "unknown")]
    Unknown,
}
#[doc = " Data governance captures information regarding data ownership, stewardship, and custodianship, "]
#[doc = " providing insights into the individuals or entities responsible for managing, overseeing, and "]
#[doc = " safeguarding the data throughout its lifecycle."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "dataGovernance")]
#[serde(deny_unknown_fields)]
pub struct DataGovernance {
    #[doc = " Data custodians are responsible for the safe custody, transport, and storage of data."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub custodians: Option<Vec<DataGovernanceResponsibleParty>>,
    #[doc = " Data owners are concerned with risk and appropriate access to data."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub owners: Option<Vec<DataGovernanceResponsibleParty>>,
    #[doc = " Data stewards are responsible for data content, context, and associated business rules."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stewards: Option<Vec<DataGovernanceResponsibleParty>>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "dataGovernanceResponsibleParty")]
#[serde(deny_unknown_fields)]
pub struct DataGovernanceResponsibleParty {
    #[doc = " The individual that is responsible for specific data governance role(s)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contact: Option<OrganizationalContact>,
    #[doc = " The organization that is responsible for specific data governance role(s)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationalEntity>,
}
#[doc = " Defines the direct dependencies of a component, service, or the components provided/implemented "]
#[doc = " by a given component. Components or services that do not have their own dependencies must be "]
#[doc = " declared as empty elements within the graph. Components or services that are not represented in "]
#[doc = " the dependency graph may have unknown dependencies. It is recommended that implementations "]
#[doc = " assume this to be opaque and not an indicator of an object being dependency-free. It is "]
#[doc = " recommended to leverage compositions to indicate unknown dependency graphs."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "dependency")]
#[serde(deny_unknown_fields)]
pub struct Dependency {
    #[doc = " The bom-ref identifiers of the components or services that are dependencies of this "]
    #[doc = " dependency object."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "dependsOn")]
    pub depends_on: Option<Vec<RefLinkType>>,
    #[doc = " The bom-ref identifiers of the components or services that define a given specification or "]
    #[doc = " standard, which are provided or implemented by this dependency object."]
    #[doc = " For example, a cryptographic library which implements a cryptographic algorithm. A "]
    #[doc = " component which implements another component does not imply that the implementation is in "]
    #[doc = " use."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provides: Option<Vec<RefLinkType>>,
    #[doc = " References a component or service by its bom-ref attribute"]
    #[serde(rename = "ref")]
    pub ref_: RefLinkType,
}
#[doc = " The patch file (or diff) that shows changes. Refer to https://en.wikipedia.org/wiki/Diff"]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "diff")]
#[serde(deny_unknown_fields)]
pub struct Diff {
    #[doc = " Specifies the optional text of the diff"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Attachment>,
    #[doc = " Specifies the URL to the diff"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}
#[doc = " Describes energy consumption information incurred for the specified lifecycle activity."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "energyConsumption")]
#[serde(deny_unknown_fields)]
pub struct EnergyConsumption {
    #[doc = " The type of activity that is part of a machine learning model development or operational "]
    #[doc = " lifecycle."]
    pub activity: String,
    #[doc = " The total energy cost associated with the model lifecycle activity."]
    #[serde(rename = "activityEnergyCost")]
    pub activity_energy_cost: EnergyMeasure,
    #[doc = " The CO2 cost (debit) equivalent to the total energy cost."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "co2CostEquivalent")]
    pub co_2_cost_equivalent: Option<Co2Measure>,
    #[doc = " The CO2 offset (credit) for the CO2 equivalent cost."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "co2CostOffset")]
    pub co_2_cost_offset: Option<Co2Measure>,
    #[doc = " The provider(s) of the energy consumed by the associated model development lifecycle "]
    #[doc = " activity."]
    #[serde(rename = "energyProviders")]
    pub energy_providers: Vec<EnergyProvider>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
}
#[doc = " A measure of energy."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "energyMeasure")]
#[serde(deny_unknown_fields)]
pub struct EnergyMeasure {
    #[doc = " Unit of energy."]
    pub unit: String,
    #[doc = " Quantity of energy."]
    pub value: f64,
}
#[doc = " Describes the physical provider of energy used for model development or operations."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "energyProvider")]
#[serde(deny_unknown_fields)]
pub struct EnergyProvider {
    #[doc = " An optional identifier which can be used to reference the energy provider elsewhere in the "]
    #[doc = " BOM. Every bom-ref must be unique within the BOM."]
    #[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with "]
    #[doc = " BOM-Links."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " A description of the energy provider."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = " The energy provided by the energy source for an associated activity."]
    #[serde(rename = "energyProvided")]
    pub energy_provided: EnergyMeasure,
    #[doc = " The energy source for the energy provider."]
    #[serde(rename = "energySource")]
    pub energy_source: String,
    #[doc = " External references provide a way to document systems, sites, and information that may be "]
    #[doc = " relevant but are not included with the BOM. They may also establish specific relationships "]
    #[doc = " within or external to the BOM."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "externalReferences")]
    pub external_references: Option<Vec<ExternalReference>>,
    #[doc = " The organization that provides energy."]
    pub organization: OrganizationalEntity,
}
#[doc = " Describes various environmental impact metrics."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "environmentalConsiderations")]
#[serde(deny_unknown_fields)]
pub struct EnvironmentalConsiderations {
    #[doc = " Describes energy consumption information incurred for one or more component lifecycle "]
    #[doc = " activities."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "energyConsumptions")]
    pub energy_consumptions: Option<Vec<EnergyConsumption>>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
}
#[doc = " Represents something that happened that may trigger a response."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "event")]
#[serde(deny_unknown_fields)]
pub struct Event {
    #[doc = " Encoding of the raw event data."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<Attachment>,
    #[doc = " A description of the event."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
    #[doc = " References the component or service that was the source of the event"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source: Option<ResourceReferenceChoice>,
    #[doc = " References the component or service that was the target of the event"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target: Option<ResourceReferenceChoice>,
    #[doc = " The date and time (timestamp) when the event was received."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "timeReceived")]
    pub time_received: Option<String>,
    #[doc = " The unique identifier of the event."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
}
#[doc = " External references provide a way to document systems, sites, and information that may be "]
#[doc = " relevant but are not included with the BOM. They may also establish specific relationships "]
#[doc = " within or external to the BOM."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "externalReference")]
#[serde(deny_unknown_fields)]
pub struct ExternalReference {
    #[doc = " An optional comment describing the external reference"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    #[doc = " The hashes of the external reference (if applicable)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hashes: Option<Vec<Hash>>,
    #[doc = " Specifies the type of external reference."]
    #[serde(rename = "type")]
    pub type_: String,
    #[doc = " The URI (URL or URN) to the external reference. External references are URIs and therefore "]
    #[doc = " can accept any URL scheme including https "]
    #[doc = " ([RFC-7230](https://www.ietf.org/rfc/rfc7230.txt)), mailto "]
    #[doc = " ([RFC-2368](https://www.ietf.org/rfc/rfc2368.txt)), tel "]
    #[doc = " ([RFC-3966](https://www.ietf.org/rfc/rfc3966.txt)), and dns "]
    #[doc = " ([RFC-4501](https://www.ietf.org/rfc/rfc4501.txt)). External references may also include "]
    #[doc = " formally registered URNs such as [CycloneDX "]
    #[doc = " BOM-Link](https://cyclonedx.org/capabilities/bomlink/) to reference CycloneDX BOMs or any "]
    #[doc = " object within a BOM. BOM-Link transforms applicable external references into relationships "]
    #[doc = " that can be expressed in a BOM or across BOMs."]
    pub url: serde_json::Value,
}
#[doc = " Information about the benefits and harms of the model to an identified at risk group."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "fairnessAssessment")]
#[serde(deny_unknown_fields)]
pub struct FairnessAssessment {
    #[doc = " Expected benefits to the identified groups."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub benefits: Option<String>,
    #[doc = " The groups or individuals at risk of being systematically disadvantaged by the model."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "groupAtRisk")]
    pub group_at_risk: Option<String>,
    #[doc = " Expected harms to the identified groups."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub harms: Option<String>,
    #[doc = " With respect to the benefits and harms outlined, please describe any mitigation strategy "]
    #[doc = " implemented."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "mitigationStrategy")]
    pub mitigation_strategy: Option<String>,
}
#[doc = " Describes workflows and resources that captures rules and other aspects of how the associated "]
#[doc = " BOM component or service was formed."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "formula")]
#[serde(deny_unknown_fields)]
pub struct Formula {
    #[doc = " An optional identifier which can be used to reference the formula elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with "]
    #[doc = " BOM-Links."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " Transient components that are used in tasks that constitute one or more of this formula's "]
    #[doc = " workflows"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub components: Option<Vec<Component>>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
    #[doc = " Transient services that are used in tasks that constitute one or more of this formula's "]
    #[doc = " workflows"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<Service>>,
    #[doc = " List of workflows that can be declared to accomplish specific orchestrated goals and "]
    #[doc = " independently triggered."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub workflows: Option<Vec<Workflow>>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "graphic")]
#[serde(deny_unknown_fields)]
pub struct Graphic {
    #[doc = " The graphic (vector or raster). Base64 encoding must be specified for binary images."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub image: Option<Attachment>,
    #[doc = " The name of the graphic."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}
#[doc = " A collection of graphics that represent various measurements."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "graphicsCollection")]
#[serde(deny_unknown_fields)]
pub struct GraphicsCollection {
    #[doc = " A collection of graphics."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collection: Option<Vec<Graphic>>,
    #[doc = " A description of this collection of graphics."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "hash")]
#[serde(deny_unknown_fields)]
pub struct Hash {
    pub alg: HashAlg,
    pub content: HashContent,
}
#[doc = " The algorithm that generated the hash value."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "hash-alg")]
pub enum HashAlg {
    #[serde(rename = "MD5")]
    Md5,
    #[serde(rename = "SHA-1")]
    Sha1,
    #[serde(rename = "SHA-256")]
    Sha256,
    #[serde(rename = "SHA-384")]
    Sha384,
    #[serde(rename = "SHA-512")]
    Sha512,
    #[serde(rename = "SHA3-256")]
    Sha3256,
    #[serde(rename = "SHA3-384")]
    Sha3384,
    #[serde(rename = "SHA3-512")]
    Sha3512,
    #[serde(rename = "BLAKE2b-256")]
    Blake2B256,
    #[serde(rename = "BLAKE2b-384")]
    Blake2B384,
    #[serde(rename = "BLAKE2b-512")]
    Blake2B512,
    #[serde(rename = "BLAKE3")]
    Blake3,
}
#[doc = " The value of the hash."]
pub type HashContent = String;
#[doc = " Specifies an individual commit"]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "identifiableAction")]
#[serde(deny_unknown_fields)]
pub struct IdentifiableAction {
    #[doc = " The email address of the individual who performed the action"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[doc = " The name of the individual who performed the action"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = " The timestamp in which the action occurred"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<String>,
}
#[doc = " The rationale of why the impact analysis state was asserted."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "impactAnalysisJustification")]
pub enum ImpactAnalysisJustification {
    #[serde(rename = "code_not_present")]
    CodeNotPresent,
    #[serde(rename = "code_not_reachable")]
    CodeNotReachable,
    #[serde(rename = "requires_configuration")]
    RequiresConfiguration,
    #[serde(rename = "requires_dependency")]
    RequiresDependency,
    #[serde(rename = "requires_environment")]
    RequiresEnvironment,
    #[serde(rename = "protected_by_compiler")]
    ProtectedByCompiler,
    #[serde(rename = "protected_at_runtime")]
    ProtectedAtRuntime,
    #[serde(rename = "protected_at_perimeter")]
    ProtectedAtPerimeter,
    #[serde(rename = "protected_by_mitigating_control")]
    ProtectedByMitigatingControl,
}
#[doc = " Declares the current state of an occurrence of a vulnerability, after automated or manual "]
#[doc = " analysis."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "impactAnalysisState")]
pub enum ImpactAnalysisState {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "resolved_with_pedigree")]
    ResolvedWithPedigree,
    #[serde(rename = "exploitable")]
    Exploitable,
    #[serde(rename = "in_triage")]
    InTriage,
    #[serde(rename = "false_positive")]
    FalsePositive,
    #[serde(rename = "not_affected")]
    NotAffected,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "inputOutputMLParameters")]
#[serde(deny_unknown_fields)]
pub struct InputOutputMLParameters {
    #[doc = " The data format for input/output to the model."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<String>,
}
pub type InputTypeItemEnvironmentVarsVariant1 = String;
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum InputTypeItemEnvironmentVars {
    Variant0(Property),
    Variant1(InputTypeItemEnvironmentVarsVariant1),
}
#[doc = " Type that represents various input data types and formats."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "inputType")]
#[serde(deny_unknown_fields)]
pub struct InputType {
    #[doc = " Inputs that have the form of data."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<Attachment>,
    #[doc = " Inputs that have the form of parameters with names and values."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "environmentVars")]
    pub environment_vars: Option<Vec<InputTypeItemEnvironmentVars>>,
    #[doc = " Inputs that have the form of parameters with names and values."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<Vec<Parameter>>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
    #[doc = " A reference to an independent resource provided as an input to a task by the workflow "]
    #[doc = " runtime."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource: Option<ResourceReferenceChoice>,
    #[doc = " A reference to the component or service that provided the input to the task (e.g., "]
    #[doc = " reference to a service with data flow value of `inbound`)"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source: Option<ResourceReferenceChoice>,
    #[doc = " A reference to the component or service that received or stored the input if not the task "]
    #[doc = " itself (e.g., a local, named storage workspace)"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target: Option<ResourceReferenceChoice>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueSource {
    #[doc = " The name of the source."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = " The url of the issue documentation as provided by the source"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}
#[doc = " An individual issue that has been resolved."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "issue")]
#[serde(deny_unknown_fields)]
pub struct Issue {
    #[doc = " A description of the issue"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = " The identifier of the issue assigned by the source of the issue"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = " The name of the issue"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = " A collection of URL's for reference. Multiple URLs are allowed."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub references: Option<Vec<String>>,
    #[doc = " The source of the issue where it is documented"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source: Option<IssueSource>,
    #[doc = " Specifies the type of issue"]
    #[serde(rename = "type")]
    pub type_: String,
}
pub type LicenseLicensingLicenseeVariant0 = serde_json::Value;
pub type LicenseLicensingLicenseeVariant1 = serde_json::Value;
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LicenseLicensingLicensee {
    Variant0(LicenseLicensingLicenseeVariant0),
    Variant1(LicenseLicensingLicenseeVariant1),
}
pub type LicenseLicensingLicensorVariant0 = serde_json::Value;
pub type LicenseLicensingLicensorVariant1 = serde_json::Value;
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LicenseLicensingLicensor {
    Variant0(LicenseLicensingLicensorVariant0),
    Variant1(LicenseLicensingLicensorVariant1),
}
pub type LicenseLicensingPurchaserVariant0 = serde_json::Value;
pub type LicenseLicensingPurchaserVariant1 = serde_json::Value;
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LicenseLicensingPurchaser {
    Variant0(LicenseLicensingPurchaserVariant0),
    Variant1(LicenseLicensingPurchaserVariant1),
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LicenseLicensing {
    #[doc = " License identifiers that may be used to manage licenses and their lifecycle"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "altIds")]
    pub alt_ids: Option<Vec<String>>,
    #[doc = " The timestamp indicating when the current license expires (if applicable)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expiration: Option<String>,
    #[doc = " The timestamp indicating when the license was last renewed. For new purchases, this is "]
    #[doc = " often the purchase or acquisition date. For non-perpetual licenses or subscriptions, this "]
    #[doc = " is the timestamp of when the license was last renewed."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "lastRenewal")]
    pub last_renewal: Option<String>,
    #[doc = " The type of license(s) that was granted to the licensee."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "licenseTypes")]
    pub license_types: Option<Vec<String>>,
    #[doc = " The individual or organization for which a license was granted to"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub licensee: Option<LicenseLicensingLicensee>,
    #[doc = " The individual or organization that grants a license to another individual or organization"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub licensor: Option<LicenseLicensingLicensor>,
    #[doc = " The purchase order identifier the purchaser sent to a supplier or vendor to authorize a "]
    #[doc = " purchase"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "purchaseOrder")]
    pub purchase_order: Option<String>,
    #[doc = " The individual or organization that purchased the license"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub purchaser: Option<LicenseLicensingPurchaser>,
}
#[doc = " Specifies the details and attributes related to a software license. It can either include a "]
#[doc = " valid SPDX license identifier or a named license, along with additional properties such as "]
#[doc = " license acknowledgment, comprehensive commercial licensing information, and the full text of "]
#[doc = " the license."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "license")]
#[serde(deny_unknown_fields)]
pub struct License {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub acknowledgement: Option<LicenseAcknowledgementEnumeration>,
    #[doc = " An optional identifier which can be used to reference the license elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with "]
    #[doc = " BOM-Links."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " A valid SPDX license identifier. If specified, this value must be one of the enumeration of "]
    #[doc = " valid SPDX license identifiers defined in the spdx.schema.json (or spdx.xml) subschema "]
    #[doc = " which is synchronized with the official SPDX license list."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = " Licensing details describing the licensor/licensee, license type, renewal and expiration "]
    #[doc = " dates, and other important metadata"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub licensing: Option<LicenseLicensing>,
    #[doc = " The name of the license. This may include the name of a commercial or proprietary license "]
    #[doc = " or an open source license that may not be defined by SPDX."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
    #[doc = " An optional way to include the textual content of a license."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Attachment>,
    #[doc = " The URL to the license file. If specified, a 'license' externalReference should also be "]
    #[doc = " specified for completeness"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}
#[doc = " Declared licenses and concluded licenses represent two different stages in the licensing "]
#[doc = " process within software development. Declared licenses refer to the initial intention of the "]
#[doc = " software authors regarding the licensing terms under which their code is released. On the other "]
#[doc = " hand, concluded licenses are the result of a comprehensive analysis of the project's codebase "]
#[doc = " to identify and confirm the actual licenses of the components used, which may differ from the "]
#[doc = " initially declared licenses. While declared licenses provide an upfront indication of the "]
#[doc = " licensing intentions, concluded licenses offer a more thorough understanding of the actual "]
#[doc = " licensing within a project, facilitating proper compliance and risk management. Observed "]
#[doc = " licenses are defined in `@.evidence.licenses`. Observed licenses form the evidence necessary to "]
#[doc = " substantiate a concluded license."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "licenseAcknowledgementEnumeration")]
pub enum LicenseAcknowledgementEnumeration {
    #[serde(rename = "declared")]
    Declared,
    #[serde(rename = "concluded")]
    Concluded,
}
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LicenseChoiceUrlVariant0ItemUrl {
    pub license: License,
}
pub type LicenseChoiceUrlVariant0 = Vec<LicenseChoiceUrlVariant0ItemUrl>;
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LicenseChoiceUrlVariant1ItemLicense {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub acknowledgement: Option<LicenseAcknowledgementEnumeration>,
    #[doc = " An optional identifier which can be used to reference the license elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with "]
    #[doc = " BOM-Links."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " A valid SPDX license expression."]
    #[doc = " Refer to https://spdx.org/specifications for syntax requirements"]
    pub expression: String,
}
pub type LicenseChoiceUrlVariant1 = Vec<LicenseChoiceUrlVariant1ItemLicense>;
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LicenseChoiceUrl {
    Variant0(LicenseChoiceUrlVariant0),
    Variant1(LicenseChoiceUrlVariant1),
}
#[doc = " EITHER (list of SPDX licenses and/or named licenses) OR (tuple of one SPDX License Expression)"]
pub type LicenseChoice = LicenseChoiceUrl;
#[doc = " Defines a syntax for representing two character language code (ISO-639) followed by an optional "]
#[doc = " two character country code. The language code must be lower case. If the country code is "]
#[doc = " specified, the country code must be upper case. The language code and country code must be "]
#[doc = " separated by a minus sign. Examples: en, en-US, fr, fr-CA"]
pub type LocaleType = String;
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MetadataItemLifecyclesVariant0 {
    #[doc = " A pre-defined phase in the product lifecycle."]
    pub phase: String,
}
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MetadataItemLifecyclesVariant1 {
    #[doc = " The description of the lifecycle phase"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = " The name of the lifecycle phase"]
    pub name: String,
}
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum MetadataItemLifecycles {
    Variant0(MetadataItemLifecyclesVariant0),
    Variant1(MetadataItemLifecyclesVariant1),
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MetadataToolsVariant0 {
    #[doc = " A list of software and hardware components used as tools."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub components: Option<Vec<Component>>,
    #[doc = " A list of services used as tools. This may include microservices, function-as-a-service, "]
    #[doc = " and other types of network or intra-process services."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<Service>>,
}
pub type MetadataToolsVariant1 = Vec<Tool>;
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum MetadataTools {
    Variant0(MetadataToolsVariant0),
    Variant1(MetadataToolsVariant1),
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "metadata")]
#[serde(deny_unknown_fields)]
pub struct Metadata {
    #[doc = " The person(s) who created the BOM."]
    #[doc = " Authors are common in BOMs created through manual processes. BOMs created through automated "]
    #[doc = " means may have `@.manufacturer` instead."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authors: Option<Vec<OrganizationalContact>>,
    #[doc = " The component that the BOM describes."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub component: Option<Component>,
    #[doc = " The license information for the BOM document."]
    #[doc = " This may be different from the license(s) of the component(s) that the BOM describes."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub licenses: Option<LicenseChoice>,
    #[doc = " Lifecycles communicate the stage(s) in which data in the BOM was captured. Different types "]
    #[doc = " of data may be available at various phases of a lifecycle, such as the Software Development "]
    #[doc = " Lifecycle (SDLC), IT Asset Management (ITAM), and Software Asset Management (SAM). Thus, a "]
    #[doc = " BOM may include data specific to or only obtainable in a given lifecycle."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lifecycles: Option<Vec<MetadataItemLifecycles>>,
    #[doc = " [Deprecated] This will be removed in a future version. Use the `@.component.manufacturer` "]
    #[doc = " instead."]
    #[doc = " The organization that manufactured the component that the BOM describes."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub manufacture: Option<OrganizationalEntity>,
    #[doc = " The organization that created the BOM."]
    #[doc = " Manufacturer is common in BOMs created through automated processes. BOMs created through "]
    #[doc = " manual means may have `@.authors` instead."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub manufacturer: Option<OrganizationalEntity>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
    #[doc = "  The organization that supplied the component that the BOM describes. The supplier may "]
    #[doc = " often be the manufacturer, but may also be a distributor or repackager."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supplier: Option<OrganizationalEntity>,
    #[doc = " The date and time (timestamp) when the BOM was created."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<String>,
    #[doc = " The tool(s) used in the creation, enrichment, and validation of the BOM."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tools: Option<MetadataTools>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ModelCardConsiderations {
    #[doc = " What are the various environmental impacts the corresponding machine learning model has "]
    #[doc = " exhibited across its lifecycle?"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "environmentalConsiderations")]
    pub environmental_considerations: Option<EnvironmentalConsiderations>,
    #[doc = " What are the ethical risks involved in the application of this model?"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "ethicalConsiderations")]
    pub ethical_considerations: Option<Vec<Risk>>,
    #[doc = " How does the model affect groups at risk of being systematically disadvantaged? What are "]
    #[doc = " the harms and benefits to the various affected groups?"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "fairnessAssessments")]
    pub fairness_assessments: Option<Vec<FairnessAssessment>>,
    #[doc = " What are the known tradeoffs in accuracy/performance of the model?"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "performanceTradeoffs")]
    pub performance_tradeoffs: Option<Vec<String>>,
    #[doc = " What are the known technical limitations of the model? E.g. What kind(s) of data should the "]
    #[doc = " model be expected not to perform well on? What are the factors that might degrade model "]
    #[doc = " performance?"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "technicalLimitations")]
    pub technical_limitations: Option<Vec<String>>,
    #[doc = " What are the intended use cases of the model?"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "useCases")]
    pub use_cases: Option<Vec<String>>,
    #[doc = " Who are the intended users of the model?"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub users: Option<Vec<String>>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ModelCardModelParametersApproach {
    #[doc = " Learning types describing the learning problem or hybrid learning problem."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "type")]
    pub type_: Option<String>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ModelCardModelParametersItemDatasetsVariant1 {
    #[doc = " References a data component by the components bom-ref attribute"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "ref")]
    pub ref_: Option<serde_json::Value>,
}
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ModelCardModelParametersItemDatasets {
    Variant0(ComponentData),
    Variant1(ModelCardModelParametersItemDatasetsVariant1),
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ModelCardModelParameters {
    #[doc = " The overall approach to learning used by the model for problem solving."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub approach: Option<ModelCardModelParametersApproach>,
    #[doc = " The model architecture family such as transformer network, convolutional neural network, "]
    #[doc = " residual neural network, LSTM neural network, etc."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "architectureFamily")]
    pub architecture_family: Option<String>,
    #[doc = " The datasets used to train and evaluate the model."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub datasets: Option<Vec<ModelCardModelParametersItemDatasets>>,
    #[doc = " The input format(s) of the model"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inputs: Option<Vec<InputOutputMLParameters>>,
    #[doc = " The specific architecture of the model such as GPT-1, ResNet-50, YOLOv3, etc."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "modelArchitecture")]
    pub model_architecture: Option<String>,
    #[doc = " The output format(s) from the model"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub outputs: Option<Vec<InputOutputMLParameters>>,
    #[doc = " Directly influences the input and/or output. Examples include classification, regression, "]
    #[doc = " clustering, etc."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task: Option<String>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ModelCardQuantitativeAnalysis {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub graphics: Option<GraphicsCollection>,
    #[doc = " The model performance metrics being reported. Examples may include accuracy, F1 score, "]
    #[doc = " precision, top-3 error rates, MSC, etc."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "performanceMetrics")]
    pub performance_metrics: Option<Vec<PerformanceMetric>>,
}
#[doc = " A model card describes the intended uses of a machine learning model and potential limitations, "]
#[doc = " including biases and ethical considerations. Model cards typically contain the training "]
#[doc = " parameters, which datasets were used to train the model, performance metrics, and other "]
#[doc = " relevant data useful for ML transparency. This object SHOULD be specified for any component of "]
#[doc = " type `machine-learning-model` and must not be specified for other component types."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "modelCard")]
#[serde(deny_unknown_fields)]
pub struct ModelCard {
    #[doc = " An optional identifier which can be used to reference the model card elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with "]
    #[doc = " BOM-Links."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " What considerations should be taken into account regarding the model's construction, "]
    #[doc = " training, and application?"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub considerations: Option<ModelCardConsiderations>,
    #[doc = " Hyper-parameters for construction of the model."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "modelParameters")]
    pub model_parameters: Option<ModelCardModelParameters>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
    #[doc = " A quantitative analysis of the model"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "quantitativeAnalysis")]
    pub quantitative_analysis: Option<ModelCardQuantitativeAnalysis>,
}
#[doc = " A note containing the locale and content."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "note")]
#[serde(deny_unknown_fields)]
pub struct Note {
    #[doc = " The ISO-639 (or higher) language code and optional ISO-3166 (or higher) country code. "]
    #[doc = " Examples include: \"en\", \"en-US\", \"fr\" and \"fr-CA\""]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub locale: Option<LocaleType>,
    #[doc = " Specifies the full content of the release note."]
    pub text: Attachment,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "organizationalContact")]
#[serde(deny_unknown_fields)]
pub struct OrganizationalContact {
    #[doc = " An optional identifier which can be used to reference the object elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with "]
    #[doc = " BOM-Links."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " The email address of the contact."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[doc = " The name of a contact"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = " The phone number of the contact."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub phone: Option<String>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "organizationalEntity")]
#[serde(deny_unknown_fields)]
pub struct OrganizationalEntity {
    #[doc = " The physical address (location) of the organization"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub address: Option<PostalAddress>,
    #[doc = " An optional identifier which can be used to reference the object elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with "]
    #[doc = " BOM-Links."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " A contact at the organization. Multiple contacts are allowed."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contact: Option<Vec<OrganizationalContact>>,
    #[doc = " The name of the organization"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = " The URL of the organization. Multiple URLs are allowed."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<Vec<String>>,
}
pub type OutputTypeItemEnvironmentVarsVariant1 = String;
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OutputTypeItemEnvironmentVars {
    Variant0(Property),
    Variant1(OutputTypeItemEnvironmentVarsVariant1),
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "outputType")]
#[serde(deny_unknown_fields)]
pub struct OutputType {
    #[doc = " Outputs that have the form of data."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<Attachment>,
    #[doc = " Outputs that have the form of environment variables."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "environmentVars")]
    pub environment_vars: Option<Vec<OutputTypeItemEnvironmentVars>>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
    #[doc = " A reference to an independent resource generated as output by the task."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource: Option<ResourceReferenceChoice>,
    #[doc = " Component or service that generated or provided the output from the task (e.g., a build "]
    #[doc = " tool)"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source: Option<ResourceReferenceChoice>,
    #[doc = " Component or service that received the output from the task (e.g., reference to an "]
    #[doc = " artifactory service with data flow value of `outbound`)"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target: Option<ResourceReferenceChoice>,
    #[doc = " Describes the type of data output."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "type")]
    pub type_: Option<String>,
}
#[doc = " A representation of a functional parameter."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "parameter")]
#[serde(deny_unknown_fields)]
pub struct Parameter {
    #[doc = " The data type of the parameter."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "dataType")]
    pub data_type: Option<String>,
    #[doc = " The name of the parameter."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = " The value of the parameter."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}
#[doc = " Specifies an individual patch"]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "patch")]
#[serde(deny_unknown_fields)]
pub struct Patch {
    #[doc = " The patch file (or diff) that shows changes. Refer to "]
    #[doc = " [https://en.wikipedia.org/wiki/Diff](https://en.wikipedia.org/wiki/Diff)"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub diff: Option<Diff>,
    #[doc = " A collection of issues the patch resolves"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resolves: Option<Vec<Issue>>,
    #[doc = " Specifies the purpose for the patch including the resolution of defects, security issues, "]
    #[doc = " or new behavior or functionality."]
    #[serde(rename = "type")]
    pub type_: String,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PerformanceMetricConfidenceInterval {
    #[doc = " The lower bound of the confidence interval."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "lowerBound")]
    pub lower_bound: Option<String>,
    #[doc = " The upper bound of the confidence interval."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "upperBound")]
    pub upper_bound: Option<String>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "performanceMetric")]
#[serde(deny_unknown_fields)]
pub struct PerformanceMetric {
    #[doc = " The confidence interval of the metric."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "confidenceInterval")]
    pub confidence_interval: Option<PerformanceMetricConfidenceInterval>,
    #[doc = " The name of the slice this metric was computed on. By default, assume this metric is not "]
    #[doc = " sliced."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub slice: Option<String>,
    #[doc = " The type of performance metric."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "type")]
    pub type_: Option<String>,
    #[doc = " The value of the performance metric."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}
#[doc = " An address used to identify a contactable location."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "postalAddress")]
#[serde(deny_unknown_fields)]
pub struct PostalAddress {
    #[doc = " An optional identifier which can be used to reference the address elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with "]
    #[doc = " BOM-Links."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " The country name or the two-letter ISO 3166-1 country code."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub country: Option<String>,
    #[doc = " The locality or city within the country."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub locality: Option<String>,
    #[doc = " The post office box number."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "postOfficeBoxNumber")]
    pub post_office_box_number: Option<String>,
    #[doc = " The postal code."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "postalCode")]
    pub postal_code: Option<String>,
    #[doc = " The region or state in the country."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[doc = " The street address."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "streetAddress")]
    pub street_address: Option<String>,
}
#[doc = " Provides the ability to document properties in a name-value store. This provides flexibility to "]
#[doc = " include data not officially supported in the standard without having to use additional "]
#[doc = " namespaces or create extensions. Unlike key-value stores, properties support duplicate names, "]
#[doc = " each potentially having different values. Property names of interest to the general public are "]
#[doc = " encouraged to be registered in the [CycloneDX Property "]
#[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
#[doc = " optional."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "property")]
#[serde(deny_unknown_fields)]
pub struct Property {
    #[doc = " The name of the property. Duplicate names are allowed, each potentially having a different "]
    #[doc = " value."]
    pub name: String,
    #[doc = " The value of the property."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}
#[doc = " Deprecated definition. use definition `versionRange` instead."]
pub type Range = VersionRange;
#[doc = " Defines the severity or risk ratings of a vulnerability."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "rating")]
#[serde(deny_unknown_fields)]
pub struct Rating {
    #[doc = " An optional reason for rating the vulnerability as it was"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub justification: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub method: Option<ScoreMethod>,
    #[doc = " The numerical score of the rating."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub score: Option<f64>,
    #[doc = " Textual representation of the severity that corresponds to the numerical score of the "]
    #[doc = " rating."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub severity: Option<Severity>,
    #[doc = " The source that calculated the severity or risk rating of the vulnerability."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source: Option<VulnerabilitySource>,
    #[doc = " Textual representation of the metric values used to score the vulnerability"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vector: Option<String>,
}
#[doc = " Descriptor for an element identified by the attribute 'bom-ref' in the same BOM document."]
#[doc = " In contrast to `bomLinkElementType`."]
pub type RefLinkType = RefType;
#[doc = " Identifier for referable and therefore interlinkable elements."]
#[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links."]
pub type RefType = String;
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "releaseNotes")]
#[serde(deny_unknown_fields)]
pub struct ReleaseNotes {
    #[doc = " One or more alternate names the release may be referred to. This may include unofficial "]
    #[doc = " terms used by development and marketing teams (e.g. code names)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aliases: Option<Vec<String>>,
    #[doc = " A short description of the release."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = " The URL to an image that may be prominently displayed with the release note."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "featuredImage")]
    pub featured_image: Option<String>,
    #[doc = " Zero or more release notes containing the locale and content. Multiple note objects may be "]
    #[doc = " specified to support release notes in a wide variety of languages."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notes: Option<Vec<Note>>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
    #[doc = " A collection of issues that have been resolved."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resolves: Option<Vec<Issue>>,
    #[doc = " The URL to an image that may be used in messaging on social media platforms."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "socialImage")]
    pub social_image: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Tags>,
    #[doc = " The date and time (timestamp) when the release note was created."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<String>,
    #[doc = " The title of the release."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    #[doc = " The software versioning type the release note describes."]
    #[serde(rename = "type")]
    pub type_: ReleaseType,
}
#[doc = " The software versioning type. It is recommended that the release type use one of 'major', "]
#[doc = " 'minor', 'patch', 'pre-release', or 'internal'. Representing all possible software release "]
#[doc = " types is not practical, so standardizing on the recommended values, whenever possible, is "]
#[doc = " strongly encouraged."]
#[doc = " "]
#[doc = " * __major__ = A major release may contain significant changes or may introduce breaking "]
#[doc = " changes."]
#[doc = " * __minor__ = A minor release, also known as an update, may contain a smaller number of changes "]
#[doc = " than major releases."]
#[doc = " * __patch__ = Patch releases are typically unplanned and may resolve defects or important "]
#[doc = " security issues."]
#[doc = " * __pre-release__ = A pre-release may include alpha, beta, or release candidates and typically "]
#[doc = " have limited support. They provide the ability to preview a release prior to its general "]
#[doc = " availability."]
#[doc = " * __internal__ = Internal releases are not for public consumption and are intended to be used "]
#[doc = " exclusively by the project or manufacturer that produced it."]
pub type ReleaseType = String;
#[doc = " A reference to a locally defined resource (e.g., a bom-ref) or an externally accessible "]
#[doc = " resource."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "resourceReferenceChoice")]
#[serde(deny_unknown_fields)]
pub struct ResourceReferenceChoice {
    #[doc = " Reference to an externally accessible resource."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "externalReference")]
    pub external_reference: Option<ExternalReference>,
    #[doc = " References an object by its bom-ref attribute"]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "ref")]
    pub ref_: Option<serde_json::Value>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "risk")]
#[serde(deny_unknown_fields)]
pub struct Risk {
    #[doc = " Strategy used to address this risk."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "mitigationStrategy")]
    pub mitigation_strategy: Option<String>,
    #[doc = " The name of the risk."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}
#[doc = " Specifies the severity or risk scoring methodology or standard used."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "scoreMethod")]
pub enum ScoreMethod {
    #[serde(rename = "CVSSv2")]
    Cvssv2,
    #[serde(rename = "CVSSv3")]
    Cvssv3,
    #[serde(rename = "CVSSv31")]
    Cvssv31,
    #[serde(rename = "CVSSv4")]
    Cvssv4,
    #[serde(rename = "OWASP")]
    Owasp,
    #[serde(rename = "SSVC")]
    Ssvc,
    #[serde(rename = "other")]
    Other,
}
#[doc = " Specifies the mechanism by which the cryptographic asset is secured by"]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "securedBy")]
#[serde(deny_unknown_fields)]
pub struct SecuredBy {
    #[doc = " The bom-ref to the algorithm."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "algorithmRef")]
    pub algorithm_ref: Option<RefType>,
    #[doc = " Specifies the mechanism by which the cryptographic asset is secured by."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mechanism: Option<String>,
}
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "service")]
#[serde(deny_unknown_fields)]
pub struct Service {
    #[doc = " A boolean value indicating if the service requires authentication. A value of true "]
    #[doc = " indicates the service requires authentication prior to use. A value of false indicates the "]
    #[doc = " service does not require authentication."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authenticated: Option<bool>,
    #[doc = " An optional identifier which can be used to reference the service elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with "]
    #[doc = " BOM-Links."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " Specifies information about the data including the directional flow of data and the data "]
    #[doc = " classification."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<Vec<ServiceData>>,
    #[doc = " Specifies a description for the service"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = " The endpoint URIs of the service. Multiple endpoints are allowed."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub endpoints: Option<Vec<String>>,
    #[doc = " External references provide a way to document systems, sites, and information that may be "]
    #[doc = " relevant but are not included with the BOM. They may also establish specific relationships "]
    #[doc = " within or external to the BOM."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "externalReferences")]
    pub external_references: Option<Vec<ExternalReference>>,
    #[doc = " The grouping name, namespace, or identifier. This will often be a shortened, single name of "]
    #[doc = " the company or project that produced the service or domain name. Whitespace and special "]
    #[doc = " characters should be avoided."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub licenses: Option<LicenseChoice>,
    #[doc = " The name of the service. This will often be a shortened, single name of the service."]
    pub name: String,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
    #[doc = " The organization that provides the service."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider: Option<OrganizationalEntity>,
    #[doc = " Specifies optional release notes."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "releaseNotes")]
    pub release_notes: Option<ReleaseNotes>,
    #[doc = " A list of services included or deployed behind the parent service. This is not a dependency "]
    #[doc = " tree. It provides a way to specify a hierarchical representation of service assemblies."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<Service>>,
    #[doc = " Enveloped signature in [JSON Signature Format "]
    #[doc = " (JSF)](https://cyberphone.github.io/doc/security/jsf.html)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<JsfSignature>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Tags>,
    #[doc = " The name of the trust zone the service resides in."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "trustZone")]
    pub trust_zone: Option<String>,
    #[doc = " The service version."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<Version>,
    #[doc = " A boolean value indicating if use of the service crosses a trust zone or boundary. A value "]
    #[doc = " of true indicates that by using the service, a trust boundary is crossed. A value of false "]
    #[doc = " indicates that by using the service, a trust boundary is not crossed."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "x-trust-boundary")]
    pub x_trust_boundary: Option<bool>,
}
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "serviceData")]
#[serde(deny_unknown_fields)]
pub struct ServiceData {
    pub classification: DataClassification,
    #[doc = " Short description of the data content and usage"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = " The URI, URL, or BOM-Link of the components or services the data is sent to"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub destination: Option<Vec<serde_json::Value>>,
    #[doc = " Specifies the flow direction of the data. Direction is relative to the service. Inbound "]
    #[doc = " flow states that data enters the service. Outbound flow states that data leaves the "]
    #[doc = " service. Bi-directional states that data flows both ways and unknown states that the "]
    #[doc = " direction is not known."]
    pub flow: DataFlowDirection,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub governance: Option<DataGovernance>,
    #[doc = " Name for the defined data"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = " The URI, URL, or BOM-Link of the components or services the data came in from"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source: Option<Vec<serde_json::Value>>,
}
#[doc = " Textual representation of the severity of the vulnerability adopted by the analysis method. If "]
#[doc = " the analysis method uses values other than what is provided, the user is expected to translate "]
#[doc = " appropriately."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "severity")]
pub enum Severity {
    #[serde(rename = "critical")]
    Critical,
    #[serde(rename = "high")]
    High,
    #[serde(rename = "medium")]
    Medium,
    #[serde(rename = "low")]
    Low,
    #[serde(rename = "info")]
    Info,
    #[serde(rename = "none")]
    None,
    #[serde(rename = "unknown")]
    Unknown,
}
#[doc = " Enveloped signature in [JSON Signature Format "]
#[doc = " (JSF)](https://cyberphone.github.io/doc/security/jsf.html)."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StandardItemLevels {
    #[doc = " An optional identifier which can be used to reference the object elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " The description of the level."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = " The identifier used in the standard to identify a specific level."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub identifier: Option<String>,
    #[doc = " The list of requirement `bom-ref`s that comprise the level."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requirements: Option<Vec<RefLinkType>>,
    #[doc = " The title of the level."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StandardItemRequirements {
    #[doc = " An optional identifier which can be used to reference the object elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " The supplemental text that provides additional guidance or context to the requirement, but "]
    #[doc = " is not directly part of the requirement."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub descriptions: Option<Vec<String>>,
    #[doc = " External references provide a way to document systems, sites, and information that may be "]
    #[doc = " relevant, but are not included with the BOM. They may also establish specific relationships "]
    #[doc = " within or external to the BOM."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "externalReferences")]
    pub external_references: Option<Vec<ExternalReference>>,
    #[doc = " The unique identifier used in the standard to identify a specific requirement. This should "]
    #[doc = " match what is in the standard and should not be the requirements bom-ref."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub identifier: Option<String>,
    #[doc = " The Common Requirements Enumeration (CRE) identifier(s). CRE is a structured and "]
    #[doc = " standardized framework for uniting security standards and guidelines. CRE links each "]
    #[doc = " section of a resource to a shared topic identifier (a Common Requirement). Through this "]
    #[doc = " shared topic link, all resources map to each other. Use of CRE promotes clear and "]
    #[doc = " unambiguous communication among stakeholders."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "openCre")]
    pub open_cre: Option<Vec<String>>,
    #[doc = " The optional `bom-ref` to a parent requirement. This establishes a hierarchy of "]
    #[doc = " requirements. Top-level requirements must not define a parent. Only child requirements "]
    #[doc = " should define parents."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<RefLinkType>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
    #[doc = " The textual content of the requirement."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
    #[doc = " The title of the requirement."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}
#[doc = " A standard may consist of regulations, industry or organizational-specific standards, maturity "]
#[doc = " models, best practices, or any other requirements which can be evaluated against or attested "]
#[doc = " to."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "standard")]
#[serde(deny_unknown_fields)]
pub struct Standard {
    #[doc = " An optional identifier which can be used to reference the object elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " The description of the standard."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = " External references provide a way to document systems, sites, and information that may be "]
    #[doc = " relevant but are not included with the BOM. They may also establish specific relationships "]
    #[doc = " within or external to the BOM."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "externalReferences")]
    pub external_references: Option<Vec<ExternalReference>>,
    #[doc = " The list of levels associated with the standard. Some standards have different levels of "]
    #[doc = " compliance."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub levels: Option<Vec<StandardItemLevels>>,
    #[doc = " The name of the standard. This will often be a shortened, single name of the standard."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = " The owner of the standard, often the entity responsible for its release."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub owner: Option<String>,
    #[doc = " The list of requirements comprising the standard."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requirements: Option<Vec<StandardItemRequirements>>,
    #[doc = " Enveloped signature in [JSON Signature Format "]
    #[doc = " (JSF)](https://cyberphone.github.io/doc/security/jsf.html)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<JsfSignature>,
    #[doc = " The version of the standard."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}
#[doc = " Executes specific commands or tools in order to accomplish its owning task as part of a "]
#[doc = " sequence."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "step")]
#[serde(deny_unknown_fields)]
pub struct Step {
    #[doc = " Ordered list of commands or directives for the step"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub commands: Option<Vec<Command>>,
    #[doc = " A description of the step."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = " A name for the step."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
}
#[doc = " Specifies metadata and content for ISO-IEC 19770-2 Software Identification (SWID) Tags."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "swid")]
#[serde(deny_unknown_fields)]
pub struct Swid {
    #[doc = " Maps to the name of a SoftwareIdentity."]
    pub name: String,
    #[doc = " Maps to the patch of a SoftwareIdentity."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub patch: Option<bool>,
    #[doc = " Maps to the tagId of a SoftwareIdentity."]
    #[serde(rename = "tagId")]
    pub tag_id: String,
    #[doc = " Maps to the tagVersion of a SoftwareIdentity."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "tagVersion")]
    pub tag_version: Option<i64>,
    #[doc = " Specifies the metadata and content of the SWID tag."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Attachment>,
    #[doc = " The URL to the SWID file."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[doc = " Maps to the version of a SoftwareIdentity."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}
#[doc = " Textual strings that aid in discovery, search, and retrieval of the associated object. Tags "]
#[doc = " often serve as a way to group or categorize similar or related objects by various attributes."]
pub type Tags = Vec<String>;
#[doc = " Describes the inputs, sequence of steps and resources used to accomplish a task and its output."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "task")]
#[serde(deny_unknown_fields)]
pub struct Task {
    #[doc = " An optional identifier which can be used to reference the task elsewhere in the BOM. Every "]
    #[doc = " bom-ref must be unique within the BOM."]
    #[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with "]
    #[doc = " BOM-Links."]
    #[serde(rename = "bom-ref")]
    pub bom_ref: RefType,
    #[doc = " A description of the resource instance."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = " Represents resources and data brought into a task at runtime by executor or task commands"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inputs: Option<Vec<InputType>>,
    #[doc = " The name of the resource instance."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = " Represents resources and data output from a task at runtime by executor or task commands"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub outputs: Option<Vec<OutputType>>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
    #[doc = " References to component or service resources that are used to realize the resource "]
    #[doc = " instance."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "resourceReferences")]
    pub resource_references: Option<Vec<ResourceReferenceChoice>>,
    #[doc = " A graph of the component runtime topology for task's instance."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "runtimeTopology")]
    pub runtime_topology: Option<Vec<Dependency>>,
    #[doc = " The sequence of steps for the task."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub steps: Option<Vec<Step>>,
    #[doc = " Indicates the types of activities performed by the set of workflow tasks."]
    #[serde(rename = "taskTypes")]
    pub task_types: Vec<TaskType>,
    #[doc = " The date and time (timestamp) when the task ended."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "timeEnd")]
    pub time_end: Option<String>,
    #[doc = " The date and time (timestamp) when the task started."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "timeStart")]
    pub time_start: Option<String>,
    #[doc = " The trigger that initiated the task."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Trigger>,
    #[doc = " The unique identifier for the resource instance within its deployment context."]
    pub uid: String,
    #[doc = " A set of named filesystem or data resource shareable by workflow tasks."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub workspaces: Option<Vec<Workspace>>,
}
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "taskType")]
pub enum TaskType {
    #[serde(rename = "copy")]
    Copy,
    #[serde(rename = "clone")]
    Clone,
    #[serde(rename = "lint")]
    Lint,
    #[serde(rename = "scan")]
    Scan,
    #[serde(rename = "merge")]
    Merge,
    #[serde(rename = "build")]
    Build,
    #[serde(rename = "test")]
    Test,
    #[serde(rename = "deliver")]
    Deliver,
    #[serde(rename = "deploy")]
    Deploy,
    #[serde(rename = "release")]
    Release,
    #[serde(rename = "clean")]
    Clean,
    #[serde(rename = "other")]
    Other,
}
#[doc = " [Deprecated] This will be removed in a future version. Use component or service instead. "]
#[doc = " Information about the automated or manual tool used"]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "tool")]
#[serde(deny_unknown_fields)]
pub struct Tool {
    #[doc = " External references provide a way to document systems, sites, and information that may be "]
    #[doc = " relevant, but are not included with the BOM. They may also establish specific relationships "]
    #[doc = " within or external to the BOM."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "externalReferences")]
    pub external_references: Option<Vec<ExternalReference>>,
    #[doc = " The hashes of the tool (if applicable)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hashes: Option<Vec<Hash>>,
    #[doc = " The name of the tool"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = " The name of the vendor who created the tool"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vendor: Option<String>,
    #[doc = " The version of the tool"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<Version>,
}
#[doc = " Represents a resource that can conditionally activate (or fire) tasks based upon associated "]
#[doc = " events and their data."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "trigger")]
#[serde(deny_unknown_fields)]
pub struct Trigger {
    #[doc = " An optional identifier which can be used to reference the trigger elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with "]
    #[doc = " BOM-Links."]
    #[serde(rename = "bom-ref")]
    pub bom_ref: RefType,
    #[doc = " A list of conditions used to determine if a trigger should be activated."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    #[doc = " A description of the resource instance."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = " The event data that caused the associated trigger to activate."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event: Option<Event>,
    #[doc = " Represents resources and data brought into a task at runtime by executor or task commands"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inputs: Option<Vec<InputType>>,
    #[doc = " The name of the resource instance."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = " Represents resources and data output from a task at runtime by executor or task commands"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub outputs: Option<Vec<OutputType>>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
    #[doc = " References to component or service resources that are used to realize the resource "]
    #[doc = " instance."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "resourceReferences")]
    pub resource_references: Option<Vec<ResourceReferenceChoice>>,
    #[doc = " The date and time (timestamp) when the trigger was activated."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "timeActivated")]
    pub time_activated: Option<String>,
    #[doc = " The source type of event which caused the trigger to fire."]
    #[serde(rename = "type")]
    pub type_: String,
    #[doc = " The unique identifier for the resource instance within its deployment context."]
    pub uid: String,
}
#[doc = " A single disjunctive version identifier, for a component or service."]
pub type Version = String;
#[doc = " A version range specified in Package URL Version Range syntax (vers) which is defined at "]
#[doc = " https://github.com/package-url/purl-spec/VERSION-RANGE-SPEC.rst"]
pub type VersionRange = String;
#[doc = " An identifiable, logical unit of data storage tied to a physical device."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "volume")]
#[serde(deny_unknown_fields)]
pub struct Volume {
    #[doc = " The mode for the volume instance."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    #[doc = " The name of the volume instance"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = " The underlying path created from the actual volume."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[doc = " Indicates if the volume persists beyond the life of the resource it is associated with."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub persistent: Option<bool>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
    #[doc = " Indicates if the volume is remotely (i.e., network) attached."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remote: Option<bool>,
    #[doc = " The allocated size of the volume accessible to the associated workspace. This should "]
    #[doc = " include the scalar size as well as IEC standard unit in either decimal or binary form."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "sizeAllocated")]
    pub size_allocated: Option<String>,
    #[doc = " The unique identifier for the volume instance within its deployment context."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
}
pub type VulnerabilityItemAffectsItemVersionsVariant0 = serde_json::Value;
pub type VulnerabilityItemAffectsItemVersionsVariant1 = serde_json::Value;
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum VulnerabilityItemAffectsItemVersions {
    Variant0(VulnerabilityItemAffectsItemVersionsVariant0),
    Variant1(VulnerabilityItemAffectsItemVersionsVariant1),
}
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct VulnerabilityItemAffects {
    #[doc = " References a component or service by the objects bom-ref"]
    #[serde(rename = "ref")]
    pub ref_: serde_json::Value,
    #[doc = " Zero or more individual versions or range of versions."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub versions: Option<Vec<VulnerabilityItemAffectsItemVersions>>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct VulnerabilityAnalysis {
    #[doc = " Detailed description of the impact including methods used during assessment. If a "]
    #[doc = " vulnerability is not exploitable, this field should include specific details on why the "]
    #[doc = " component or service is not impacted by this vulnerability."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub detail: Option<String>,
    #[doc = " The date and time (timestamp) when the analysis was first issued."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "firstIssued")]
    pub first_issued: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub justification: Option<ImpactAnalysisJustification>,
    #[doc = " The date and time (timestamp) when the analysis was last updated."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "lastUpdated")]
    pub last_updated: Option<String>,
    #[doc = " A response to the vulnerability by the manufacturer, supplier, or project responsible for "]
    #[doc = " the affected component or service. More than one response is allowed. Responses are "]
    #[doc = " strongly encouraged for vulnerabilities where the analysis state is exploitable."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub response: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<ImpactAnalysisState>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct VulnerabilityCredits {
    #[doc = " The individuals, not associated with organizations, that are credited with vulnerability "]
    #[doc = " discovery."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub individuals: Option<Vec<OrganizationalContact>>,
    #[doc = " The organizations credited with vulnerability discovery."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub organizations: Option<Vec<OrganizationalEntity>>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
pub struct VulnerabilityProofOfConcept {
    #[doc = " A description of the environment in which reproduction was possible."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub environment: Option<String>,
    #[doc = " Precise steps to reproduce the vulnerability."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "reproductionSteps")]
    pub reproduction_steps: Option<String>,
    #[doc = " Supporting material that helps in reproducing or understanding how reproduction is "]
    #[doc = " possible. This may include screenshots, payloads, and PoC exploit code."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "supportingMaterial")]
    pub supporting_material: Option<Vec<Attachment>>,
}
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct VulnerabilityItemReferences {
    #[doc = " An identifier that uniquely identifies the vulnerability."]
    pub id: String,
    #[doc = " The source that published the vulnerability."]
    pub source: VulnerabilitySource,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct VulnerabilityToolsVariant0 {
    #[doc = " A list of software and hardware components used as tools."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub components: Option<Vec<Component>>,
    #[doc = " A list of services used as tools. This may include microservices, function-as-a-service, "]
    #[doc = " and other types of network or intra-process services."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<Service>>,
}
pub type VulnerabilityToolsVariant1 = Vec<Tool>;
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum VulnerabilityTools {
    Variant0(VulnerabilityToolsVariant0),
    Variant1(VulnerabilityToolsVariant1),
}
#[doc = " Defines a weakness in a component or service that could be exploited or triggered by a threat "]
#[doc = " source."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "vulnerability")]
#[serde(deny_unknown_fields)]
pub struct Vulnerability {
    #[doc = " Published advisories of the vulnerability if provided."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub advisories: Option<Vec<Advisory>>,
    #[doc = " The components or services that are affected by the vulnerability."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub affects: Option<Vec<VulnerabilityItemAffects>>,
    #[doc = " An assessment of the impact and exploitability of the vulnerability."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub analysis: Option<VulnerabilityAnalysis>,
    #[doc = " An optional identifier which can be used to reference the vulnerability elsewhere in the "]
    #[doc = " BOM. Every bom-ref must be unique within the BOM."]
    #[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with "]
    #[doc = " BOM-Links."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " The date and time (timestamp) when the vulnerability record was created in the "]
    #[doc = " vulnerability database."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created: Option<String>,
    #[doc = " Individuals or organizations credited with the discovery of the vulnerability."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub credits: Option<VulnerabilityCredits>,
    #[doc = " List of Common Weaknesses Enumerations (CWEs) codes that describes this vulnerability."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cwes: Option<Vec<Cwe>>,
    #[doc = " A description of the vulnerability as provided by the source."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = " If available, an in-depth description of the vulnerability as provided by the source "]
    #[doc = " organization. Details often include information useful in understanding root cause."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub detail: Option<String>,
    #[doc = " The identifier that uniquely identifies the vulnerability."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = " Evidence used to reproduce the vulnerability."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "proofOfConcept")]
    pub proof_of_concept: Option<VulnerabilityProofOfConcept>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
    #[doc = " The date and time (timestamp) when the vulnerability record was first published."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub published: Option<String>,
    #[doc = " List of vulnerability ratings"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ratings: Option<Vec<Rating>>,
    #[doc = " Recommendations of how the vulnerability can be remediated or mitigated."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendation: Option<String>,
    #[doc = " Zero or more pointers to vulnerabilities that are the equivalent of the vulnerability "]
    #[doc = " specified. Often times, the same vulnerability may exist in multiple sources of "]
    #[doc = " vulnerability intelligence, but have different identifiers. References provide a way to "]
    #[doc = " correlate vulnerabilities across multiple sources of vulnerability intelligence."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub references: Option<Vec<VulnerabilityItemReferences>>,
    #[doc = " The date and time (timestamp) when the vulnerability record was rejected (if applicable)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rejected: Option<String>,
    #[doc = " The source that published the vulnerability."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source: Option<VulnerabilitySource>,
    #[doc = " The tool(s) used to identify, confirm, or score the vulnerability."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tools: Option<VulnerabilityTools>,
    #[doc = " The date and time (timestamp) when the vulnerability record was last updated."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated: Option<String>,
    #[doc = " A bypass, usually temporary, of the vulnerability that reduces its likelihood and/or "]
    #[doc = " impact. Workarounds often involve changes to configuration or deployments."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub workaround: Option<String>,
}
#[doc = " The source of vulnerability information. This is often the organization that published the "]
#[doc = " vulnerability."]
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(rename = "vulnerabilitySource")]
#[serde(deny_unknown_fields)]
pub struct VulnerabilitySource {
    #[doc = " The name of the source."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = " The url of the vulnerability documentation as provided by the source."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}
#[doc = " A specialized orchestration task."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "workflow")]
#[serde(deny_unknown_fields)]
pub struct Workflow {
    #[doc = " An optional identifier which can be used to reference the workflow elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with "]
    #[doc = " BOM-Links."]
    #[serde(rename = "bom-ref")]
    pub bom_ref: RefType,
    #[doc = " A description of the resource instance."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = " Represents resources and data brought into a task at runtime by executor or task commands"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inputs: Option<Vec<InputType>>,
    #[doc = " The name of the resource instance."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = " Represents resources and data output from a task at runtime by executor or task commands"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub outputs: Option<Vec<OutputType>>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
    #[doc = " References to component or service resources that are used to realize the resource "]
    #[doc = " instance."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "resourceReferences")]
    pub resource_references: Option<Vec<ResourceReferenceChoice>>,
    #[doc = " A graph of the component runtime topology for workflow's instance."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "runtimeTopology")]
    pub runtime_topology: Option<Vec<Dependency>>,
    #[doc = " The sequence of steps for the task."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub steps: Option<Vec<Step>>,
    #[doc = " The graph of dependencies between tasks within the workflow."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "taskDependencies")]
    pub task_dependencies: Option<Vec<Dependency>>,
    #[doc = " Indicates the types of activities performed by the set of workflow tasks."]
    #[serde(rename = "taskTypes")]
    pub task_types: Vec<TaskType>,
    #[doc = " The tasks that comprise the workflow."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tasks: Option<Vec<Task>>,
    #[doc = " The date and time (timestamp) when the task ended."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "timeEnd")]
    pub time_end: Option<String>,
    #[doc = " The date and time (timestamp) when the task started."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "timeStart")]
    pub time_start: Option<String>,
    #[doc = " The trigger that initiated the task."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Trigger>,
    #[doc = " The unique identifier for the resource instance within its deployment context."]
    pub uid: String,
    #[doc = " A set of named filesystem or data resource shareable by workflow tasks."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub workspaces: Option<Vec<Workspace>>,
}
#[doc = " A named filesystem or data resource shareable by workflow tasks."]
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "workspace")]
#[serde(deny_unknown_fields)]
pub struct Workspace {
    #[doc = " Describes the read-write access control for the workspace relative to the owning resource "]
    #[doc = " instance."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "accessMode")]
    pub access_mode: Option<String>,
    #[doc = " The names for the workspace as referenced by other workflow tasks. Effectively, a name "]
    #[doc = " mapping so other tasks can use their own local name in their steps."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aliases: Option<Vec<String>>,
    #[doc = " An optional identifier which can be used to reference the workspace elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[doc = " Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with "]
    #[doc = " BOM-Links."]
    #[serde(rename = "bom-ref")]
    pub bom_ref: RefType,
    #[doc = " A description of the resource instance."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = " The name of a domain-specific data type the workspace represents."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "managedDataType")]
    pub managed_data_type: Option<String>,
    #[doc = " A path to a location on disk where the workspace will be available to the associated task's "]
    #[doc = " steps."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "mountPath")]
    pub mount_path: Option<String>,
    #[doc = " The name of the resource instance."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
    #[doc = " References to component or service resources that are used to realize the resource "]
    #[doc = " instance."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "resourceReferences")]
    pub resource_references: Option<Vec<ResourceReferenceChoice>>,
    #[doc = " The unique identifier for the resource instance within its deployment context."]
    pub uid: String,
    #[doc = " Information about the actual volume instance allocated to the workspace."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub volume: Option<Volume>,
    #[doc = " Identifies the reference to the request for a specific volume type and parameters."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "volumeRequest")]
    pub volume_request: Option<String>,
}
pub type SchemaDeclarationsAffirmationItemSignatoriesVariant0 = serde_json::Value;
pub type SchemaDeclarationsAffirmationItemSignatoriesVariant1 = serde_json::Value;
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SchemaDeclarationsAffirmationItemSignatories {
    Variant0(SchemaDeclarationsAffirmationItemSignatoriesVariant0),
    Variant1(SchemaDeclarationsAffirmationItemSignatoriesVariant1),
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SchemaDeclarationsAffirmation {
    #[doc = " The list of signatories authorized on behalf of an organization to assert validity of this "]
    #[doc = " document."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signatories: Option<Vec<SchemaDeclarationsAffirmationItemSignatories>>,
    #[doc = " Enveloped signature in [JSON Signature Format "]
    #[doc = " (JSF)](https://cyberphone.github.io/doc/security/jsf.html)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<JsfSignature>,
    #[doc = " The brief statement affirmed by an individual regarding all declarations."]
    #[doc = " *- Notes This could be an affirmation of acceptance by a third-party auditor or receiving "]
    #[doc = " individual of a file."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub statement: Option<String>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SchemaDeclarationsItemAssessors {
    #[doc = " An optional identifier which can be used to reference the object elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " The entity issuing the assessment."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub organization: Option<OrganizationalEntity>,
    #[doc = " The boolean indicating if the assessor is outside the organization generating claims. A "]
    #[doc = " value of false indicates a self assessor."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "thirdParty")]
    pub third_party: Option<bool>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SchemaDeclarationsItemAttestationsItemMapConfidence {
    #[doc = " The rationale for the confidence score."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rationale: Option<String>,
    #[doc = " The confidence of the claim between and inclusive of 0 and 1, where 1 is 100% confidence."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub score: Option<f64>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SchemaDeclarationsItemAttestationsItemMapConformance {
    #[doc = " The list of  `bom-ref` to the evidence provided describing the mitigation strategies."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "mitigationStrategies")]
    pub mitigation_strategies: Option<Vec<RefLinkType>>,
    #[doc = " The rationale for the conformance score."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rationale: Option<String>,
    #[doc = " The conformance of the claim between and inclusive of 0 and 1, where 1 is 100% conformance."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub score: Option<f64>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SchemaDeclarationsItemAttestationsItemMap {
    #[doc = " The list of `bom-ref` to the claims being attested to."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<RefLinkType>>,
    #[doc = " The confidence of the claim meeting the requirement."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub confidence: Option<SchemaDeclarationsItemAttestationsItemMapConfidence>,
    #[doc = " The conformance of the claim meeting a requirement."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conformance: Option<SchemaDeclarationsItemAttestationsItemMapConformance>,
    #[doc = " The list of  `bom-ref` to the counter claims being attested to."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "counterClaims")]
    pub counter_claims: Option<Vec<RefLinkType>>,
    #[doc = " The `bom-ref` to the requirement being attested to."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requirement: Option<RefLinkType>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SchemaDeclarationsItemAttestations {
    #[doc = " The `bom-ref` to the assessor asserting the attestation."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assessor: Option<RefLinkType>,
    #[doc = " The grouping of requirements to claims and the attestors declared conformance and "]
    #[doc = " confidence thereof."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub map: Option<Vec<SchemaDeclarationsItemAttestationsItemMap>>,
    #[doc = " Enveloped signature in [JSON Signature Format "]
    #[doc = " (JSF)](https://cyberphone.github.io/doc/security/jsf.html)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<JsfSignature>,
    #[doc = " The short description explaining the main points of the attestation."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SchemaDeclarationsItemClaims {
    #[doc = " An optional identifier which can be used to reference the object elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " The list of `bom-ref` to counterEvidence that supports this claim."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "counterEvidence")]
    pub counter_evidence: Option<Vec<RefLinkType>>,
    #[doc = " The list of `bom-ref` to evidence that supports this claim."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub evidence: Option<Vec<RefLinkType>>,
    #[doc = " External references provide a way to document systems, sites, and information that may be "]
    #[doc = " relevant but are not included with the BOM. They may also establish specific relationships "]
    #[doc = " within or external to the BOM."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "externalReferences")]
    pub external_references: Option<Vec<ExternalReference>>,
    #[doc = " The list of  `bom-ref` to the evidence provided describing the mitigation strategies. Each "]
    #[doc = " mitigation strategy should include an explanation of how any weaknesses in the evidence "]
    #[doc = " will be mitigated."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "mitigationStrategies")]
    pub mitigation_strategies: Option<Vec<RefLinkType>>,
    #[doc = " The specific statement or assertion about the target."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub predicate: Option<String>,
    #[doc = " The written explanation of why the evidence provided substantiates the claim."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reasoning: Option<String>,
    #[doc = " Enveloped signature in [JSON Signature Format "]
    #[doc = " (JSF)](https://cyberphone.github.io/doc/security/jsf.html)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<JsfSignature>,
    #[doc = " The `bom-ref` to a target representing a specific system, application, API, module, team, "]
    #[doc = " person, process, business unit, company, etc...  that this claim is being applied to."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target: Option<RefLinkType>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SchemaDeclarationsItemEvidenceItemDataContents {
    #[doc = " An optional way to include textual or encoded data."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attachment: Option<Attachment>,
    #[doc = " The URL to where the data can be retrieved."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SchemaDeclarationsItemEvidenceItemData {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub classification: Option<DataClassification>,
    #[doc = " The contents or references to the contents of the data being described."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<SchemaDeclarationsItemEvidenceItemDataContents>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub governance: Option<DataGovernance>,
    #[doc = " The name of the data."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = " A description of any sensitive data included."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "sensitiveData")]
    pub sensitive_data: Option<Vec<String>>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SchemaDeclarationsItemEvidence {
    #[doc = " The author of the evidence."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub author: Option<OrganizationalContact>,
    #[doc = " An optional identifier which can be used to reference the object elsewhere in the BOM. "]
    #[doc = " Every bom-ref must be unique within the BOM."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "bom-ref")]
    pub bom_ref: Option<RefType>,
    #[doc = " The date and time (timestamp) when the evidence was created."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created: Option<String>,
    #[doc = " The output or analysis that supports claims."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<Vec<SchemaDeclarationsItemEvidenceItemData>>,
    #[doc = " The written description of what this evidence is and how it was created."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = " The optional date and time (timestamp) when the evidence is no longer valid."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires: Option<String>,
    #[doc = " The reference to the property name as defined in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy/)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "propertyName")]
    pub property_name: Option<String>,
    #[doc = " The reviewer of the evidence."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reviewer: Option<OrganizationalContact>,
    #[doc = " Enveloped signature in [JSON Signature Format "]
    #[doc = " (JSF)](https://cyberphone.github.io/doc/security/jsf.html)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<JsfSignature>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SchemaDeclarationsTargets {
    #[doc = " The list of components which claims are made against."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub components: Option<Vec<Component>>,
    #[doc = " The list of organizations which claims are made against."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub organizations: Option<Vec<OrganizationalEntity>>,
    #[doc = " The list of services which claims are made against."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<Service>>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SchemaDeclarations {
    #[doc = " A concise statement affirmed by an individual regarding all declarations, often used for "]
    #[doc = " third-party auditor acceptance or recipient acknowledgment. It includes a list of "]
    #[doc = " authorized signatories who assert the validity of the document on behalf of the "]
    #[doc = " organization."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub affirmation: Option<SchemaDeclarationsAffirmation>,
    #[doc = " The list of assessors evaluating claims and determining conformance to requirements and "]
    #[doc = " confidence in that assessment."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assessors: Option<Vec<SchemaDeclarationsItemAssessors>>,
    #[doc = " The list of attestations asserted by an assessor that maps requirements to claims."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attestations: Option<Vec<SchemaDeclarationsItemAttestations>>,
    #[doc = " The list of claims."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<SchemaDeclarationsItemClaims>>,
    #[doc = " The list of evidence"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub evidence: Option<Vec<SchemaDeclarationsItemEvidence>>,
    #[doc = " Enveloped signature in [JSON Signature Format "]
    #[doc = " (JSF)](https://cyberphone.github.io/doc/security/jsf.html)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<JsfSignature>,
    #[doc = " The list of targets which claims are made against."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub targets: Option<SchemaDeclarationsTargets>,
}
#[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SchemaDefinitions {
    #[doc = " The list of standards which may consist of regulations, industry or organizational-specific "]
    #[doc = " standards, maturity models, best practices, or any other requirements which can be "]
    #[doc = " evaluated against or attested to."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub standards: Option<Vec<Standard>>,
}
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CdxBom {
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "$schema")]
    pub schema: Option<String>,
    #[doc = " Comments made by people, organizations, or tools about any object with a bom-ref, such as "]
    #[doc = " components, services, vulnerabilities, or the BOM itself. Unlike inventory information, "]
    #[doc = " annotations may contain opinions or commentary from various stakeholders. Annotations may "]
    #[doc = " be inline (with inventory) or externalized via BOM-Link and may optionally be signed."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub annotations: Option<Vec<Annotations>>,
    #[doc = " Specifies the format of the BOM. This helps to identify the file as CycloneDX since BOMs do "]
    #[doc = " not have a filename convention, nor does JSON schema support namespaces. This value must be "]
    #[doc = " \"CycloneDX\"."]
    #[serde(rename = "bomFormat")]
    pub bom_format: String,
    #[doc = " A list of software and hardware components."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub components: Option<Vec<Component>>,
    #[doc = " Compositions describe constituent parts (including components, services, and dependency "]
    #[doc = " relationships) and their completeness. The completeness of vulnerabilities expressed in a "]
    #[doc = " BOM may also be described."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compositions: Option<Vec<Compositions>>,
    #[doc = " The list of declarations which describe the conformance to standards. Each declaration may "]
    #[doc = " include attestations, claims, and evidence."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub declarations: Option<SchemaDeclarations>,
    #[doc = " A collection of reusable objects that are defined and may be used elsewhere in the BOM."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub definitions: Option<SchemaDefinitions>,
    #[doc = " Provides the ability to document dependency relationships including provided & implemented "]
    #[doc = " components."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dependencies: Option<Vec<Dependency>>,
    #[doc = " External references provide a way to document systems, sites, and information that may be "]
    #[doc = " relevant but are not included with the BOM. They may also establish specific relationships "]
    #[doc = " within or external to the BOM."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "externalReferences")]
    pub external_references: Option<Vec<ExternalReference>>,
    #[doc = " Describes how a component or service was manufactured or deployed. This is achieved through "]
    #[doc = " the use of formulas, workflows, tasks, and steps, which declare the precise steps to "]
    #[doc = " reproduce along with the observed formulas describing the steps which transpired in the "]
    #[doc = " manufacturing process."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub formulation: Option<Vec<Formula>>,
    #[doc = " Provides additional information about a BOM."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Metadata>,
    #[doc = " Provides the ability to document properties in a name-value store. This provides "]
    #[doc = " flexibility to include data not officially supported in the standard without having to use "]
    #[doc = " additional namespaces or create extensions. Unlike key-value stores, properties support "]
    #[doc = " duplicate names, each potentially having different values. Property names of interest to "]
    #[doc = " the general public are encouraged to be registered in the [CycloneDX Property "]
    #[doc = " Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is "]
    #[doc = " optional."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Vec<Property>>,
    #[doc = " Every BOM generated SHOULD have a unique serial number, even if the contents of the BOM "]
    #[doc = " have not changed over time. If specified, the serial number must conform to [RFC "]
    #[doc = " 4122](https://www.ietf.org/rfc/rfc4122.html). Use of serial numbers is recommended."]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "serialNumber")]
    pub serial_number: Option<String>,
    #[doc = " A list of services. This may include microservices, function-as-a-service, and other types "]
    #[doc = " of network or intra-process services."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<Service>>,
    #[doc = " Enveloped signature in [JSON Signature Format "]
    #[doc = " (JSF)](https://cyberphone.github.io/doc/security/jsf.html)."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<JsfSignature>,
    #[doc = " The version of the CycloneDX specification the BOM conforms to."]
    #[serde(rename = "specVersion")]
    pub spec_version: String,
    #[doc = " Whenever an existing BOM is modified, either manually or through automated processes, the "]
    #[doc = " version of the BOM SHOULD be incremented by 1. When a system is presented with multiple "]
    #[doc = " BOMs with identical serial numbers, the system SHOULD use the most recent version of the "]
    #[doc = " BOM. The default version is '1'."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
    #[doc = " Vulnerabilities identified in components or services."]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vulnerabilities: Option<Vec<Vulnerability>>,
}
